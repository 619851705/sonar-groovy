<!-- Generated using CodeNarc 0.23 -->
<rules>

  <!-- basic rules -->

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.basic.AssignmentInConditionalRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Assignment In Conditional]]></name>
    <internalKey><![CDATA[AssignmentInConditional]]></internalKey>
    <description><![CDATA[An assignment operator (=) was used in a conditional test. This is usually a typo, and the comparison operator (==) was intended.]]></description>
    <tag>basic</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.basic.BigDecimalInstantiationRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Big Decimal Instantiation]]></name>
    <internalKey><![CDATA[BigDecimalInstantiation]]></internalKey>
    <description><![CDATA[Checks for calls to the <em>BigDecimal</em> constructors that take a <em>double</em> parameter, which may result in an unexpected <em>BigDecimal</em> value.]]></description>
    <tag>basic</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.basic.BooleanGetBooleanRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Boolean Get Boolean]]></name>
    <internalKey><![CDATA[BooleanGetBoolean]]></internalKey>
    <description><![CDATA[This rule catches usages of java.lang.Boolean.getBoolean(String) which reads a boolean from the System properties. It is often mistakenly used to attempt to read user input or parse a String into a boolean. It is a poor piece of API to use; replace it with System.properties['prop'].]]></description>
    <tag>basic</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.basic.BrokenOddnessCheckRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Broken Oddness Check]]></name>
    <internalKey><![CDATA[BrokenOddnessCheck]]></internalKey>
    <description><![CDATA[The code uses x % 2 == 1 to check to see if a value is odd, but this won't work for negative numbers (e.g., (-5) % 2 == -1). If this code is intending to check for oddness, consider using x &amp; 1 == 1, or x % 2 != 0.]]></description>
    <tag>basic</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.basic.ConstantIfExpressionRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Constant If Expression]]></name>
    <internalKey><![CDATA[ConstantIfExpression]]></internalKey>
    <description><![CDATA[Checks for <em>if</em> statements with a constant value for the if expression, such as <em>true</em>, <em>false</em>, <em>null</em>, or a literal constant value.]]></description>
    <tag>basic</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.basic.ConstantTernaryExpressionRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Constant Ternary Expression]]></name>
    <internalKey><![CDATA[ConstantTernaryExpression]]></internalKey>
    <description><![CDATA[Checks for ternary expressions with a constant value for the boolean expression, such as <em>true</em>, <em>false</em>, <em>null</em>, or a literal constant value.]]></description>
    <tag>basic</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.basic.DeadCodeRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Dead Code]]></name>
    <internalKey><![CDATA[DeadCode]]></internalKey>
    <description><![CDATA[Dead code appears after a return statement or an exception is thrown. If code appears after one of these statements then it will never be executed and can be safely deleted.]]></description>
    <tag>basic</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.basic.DoubleNegativeRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Double Negative]]></name>
    <internalKey><![CDATA[DoubleNegative]]></internalKey>
    <description><![CDATA[There is no point in using a double negative, it is always positive. For instance <em>!!x</em> can always be simplified to x. And <em>!(!x)</em> can as well.]]></description>
    <tag>basic</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.basic.DuplicateCaseStatementRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Duplicate Case Statement]]></name>
    <internalKey><![CDATA[DuplicateCaseStatement]]></internalKey>
    <description><![CDATA[Check for duplicate <em>case</em> statements in a <em>switch</em> block, such as two equal integers or strings.]]></description>
    <tag>basic</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.basic.EmptyCatchBlockRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Empty Catch Block]]></name>
    <internalKey><![CDATA[EmptyCatchBlock]]></internalKey>
    <description><![CDATA[In most cases, exceptions should not be caught and ignored (swallowed).]]></description>
    <tag>basic</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.basic.EmptyElseBlockRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Empty Else Block]]></name>
    <internalKey><![CDATA[EmptyElseBlock]]></internalKey>
    <description><![CDATA[Empty <em>else</em> blocks are confusing and serve no purpose.]]></description>
    <tag>basic</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.basic.EmptyFinallyBlockRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Empty Finally Block]]></name>
    <internalKey><![CDATA[EmptyFinallyBlock]]></internalKey>
    <description><![CDATA[Empty <em>finally</em> blocks are confusing and serve no purpose.]]></description>
    <tag>basic</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.basic.EmptyForStatementRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Empty For Statement]]></name>
    <internalKey><![CDATA[EmptyForStatement]]></internalKey>
    <description><![CDATA[Empty <em>for</em> statements are confusing and serve no purpose.]]></description>
    <tag>basic</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.basic.EmptyIfStatementRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Empty If Statement]]></name>
    <internalKey><![CDATA[EmptyIfStatement]]></internalKey>
    <description><![CDATA[Empty <em>if</em> statements are confusing and serve no purpose.]]></description>
    <tag>basic</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.basic.EmptyInstanceInitializerRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Empty Instance Initializer]]></name>
    <internalKey><![CDATA[EmptyInstanceInitializer]]></internalKey>
    <description><![CDATA[An empty class instance initializer was found. It is safe to remove it.]]></description>
    <tag>basic</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.basic.EmptyMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Empty Method]]></name>
    <internalKey><![CDATA[EmptyMethod]]></internalKey>
    <description><![CDATA[A method was found without an implementation. If the method is overriding or implementing a parent method, then mark it with the @Override annotation.]]></description>
    <tag>basic</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.basic.EmptyStaticInitializerRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Empty Static Initializer]]></name>
    <internalKey><![CDATA[EmptyStaticInitializer]]></internalKey>
    <description><![CDATA[An empty static initializer was found. It is safe to remove it.]]></description>
    <tag>basic</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.basic.EmptySwitchStatementRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Empty Switch Statement]]></name>
    <internalKey><![CDATA[EmptySwitchStatement]]></internalKey>
    <description><![CDATA[Empty <em>switch</em> statements are confusing and serve no purpose.]]></description>
    <tag>basic</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.basic.EmptySynchronizedStatementRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Empty Synchronized Statement]]></name>
    <internalKey><![CDATA[EmptySynchronizedStatement]]></internalKey>
    <description><![CDATA[Empty <em>synchronized</em> statements are confusing and serve no purpose.]]></description>
    <tag>basic</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.basic.EmptyTryBlockRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Empty Try Block]]></name>
    <internalKey><![CDATA[EmptyTryBlock]]></internalKey>
    <description><![CDATA[Empty <em>try</em> blocks are confusing and serve no purpose.]]></description>
    <tag>basic</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.basic.EmptyWhileStatementRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Empty While Statement]]></name>
    <internalKey><![CDATA[EmptyWhileStatement]]></internalKey>
    <description><![CDATA[Empty <em>while</em> statements are confusing and serve no purpose.]]></description>
    <tag>basic</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.basic.EqualsAndHashCodeRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Equals And Hash Code]]></name>
    <internalKey><![CDATA[EqualsAndHashCode]]></internalKey>
    <description><![CDATA[If either the <em>boolean equals(Object)</em> or the <em>int hashCode()</em> methods are overridden within a class, then both must be overridden.]]></description>
    <tag>basic</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.basic.ExplicitGarbageCollectionRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Garbage Collection]]></name>
    <internalKey><![CDATA[ExplicitGarbageCollection]]></internalKey>
    <description><![CDATA[Calls to System.gc(), Runtime.getRuntime().gc(), and System.runFinalization() are not advised. Code should have the same behavior whether the garbage collection is disabled using the option -Xdisableexplicitgc or not. Moreover, "modern" jvms do a very good job handling garbage collections. If memory usage issues unrelated to memory leaks develop within an application, it should be dealt with JVM options rather than within the code itself.]]></description>
    <tag>basic</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.basic.IntegerGetIntegerRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Integer Get Integer]]></name>
    <internalKey><![CDATA[IntegerGetInteger]]></internalKey>
    <description><![CDATA[This rule catches usages of java.lang.Integer.getInteger(String, ...) which reads an Integer from the System properties. It is often mistakenly used to attempt to read user input or parse a String into an Integer. It is a poor piece of API to use; replace it with System.properties['prop'].]]></description>
    <tag>basic</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.basic.RemoveAllOnSelfRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Remove All On Self]]></name>
    <internalKey><![CDATA[RemoveAllOnSelf]]></internalKey>
    <description><![CDATA[Don't use <em>removeAll</em> to clear a collection. If you want to remove all elements from a collection c, use c.clear, not c.removeAll(c). Calling <em>c.removeAll(c)</em> to clear a collection is less clear, susceptible to errors from typos, less efficient and for some collections, might throw a <em>ConcurrentModificationException</em>.]]></description>
    <tag>basic</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.basic.ReturnFromFinallyBlockRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Return From Finally Block]]></name>
    <internalKey><![CDATA[ReturnFromFinallyBlock]]></internalKey>
    <description><![CDATA[Returning from a <em>finally</em> block is confusing and can hide the original exception.]]></description>
    <tag>basic</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.basic.ThrowExceptionFromFinallyBlockRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Throw Exception From Finally Block]]></name>
    <internalKey><![CDATA[ThrowExceptionFromFinallyBlock]]></internalKey>
    <description><![CDATA[Throwing an exception from a <em>finally</em> block is confusing and can hide the original exception.]]></description>
    <tag>basic</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.basic.DuplicateMapKeyRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Duplicate Map Key]]></name>
    <internalKey><![CDATA[DuplicateMapKey]]></internalKey>
    <description><![CDATA[A map literal is created with duplicated key. The map entry will be overwritten.]]></description>
    <tag>basic</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.basic.DuplicateSetValueRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Duplicate Set Value]]></name>
    <internalKey><![CDATA[DuplicateSetValue]]></internalKey>
    <description><![CDATA[A Set literal is created with duplicate constant value. A set cannot contain two elements with the same value.]]></description>
    <tag>basic</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.basic.EqualsOverloadedRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Equals Overloaded]]></name>
    <internalKey><![CDATA[EqualsOverloaded]]></internalKey>
    <description><![CDATA[The class has an equals method, but the parameter of the method is not of type Object. It is not overriding equals but instead overloading it.]]></description>
    <tag>basic</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.basic.ForLoopShouldBeWhileLoopRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[For Loop Should Be While Loop]]></name>
    <internalKey><![CDATA[ForLoopShouldBeWhileLoop]]></internalKey>
    <description><![CDATA[A for loop without an init and update statement can be simplified to a while loop.]]></description>
    <tag>basic</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.basic.ClassForNameRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Class For Name]]></name>
    <internalKey><![CDATA[ClassForName]]></internalKey>
    <description><![CDATA[Using Class.forName(...) is a common way to add dynamic behavior to a system. However, using this method can cause resource leaks because the classes can be pinned in memory for long periods of time.]]></description>
    <tag>basic</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.basic.ComparisonOfTwoConstantsRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Comparison Of Two Constants]]></name>
    <internalKey><![CDATA[ComparisonOfTwoConstants]]></internalKey>
    <description><![CDATA[Checks for expressions where a comparison operator or <em>equals()</em> or <em>compareTo()</em> is used to compare two constants to each other or two literals that contain only constant values., e.g.: <em>23 == 67, Boolean.FALSE != false, 0.17 &lt;= 0.99, "abc" &gt; "ddd", [a:1] &lt;=&gt; [a:2], [1,2].equals([3,4]) or [a:false, b:true].compareTo(['a':34.5, b:Boolean.TRUE]</em>.]]></description>
    <tag>basic</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.basic.ComparisonWithSelfRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Comparison With Self]]></name>
    <internalKey><![CDATA[ComparisonWithSelf]]></internalKey>
    <description><![CDATA[Checks for expressions where a comparison operator or <em>equals()</em> or <em>compareTo()</em> is used to compare a variable to itself, e.g.: <em>x == x, x != x, x &lt;=&gt; x, x &lt; x, x =&gt;= x, x.equals(x) or x.compareTo(x)</em>, where <em>x</em> is a variable.]]></description>
    <tag>basic</tag>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.basic.BitwiseOperatorInConditionalRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Bitwise Operator In Conditional]]></name>
    <internalKey><![CDATA[BitwiseOperatorInConditional]]></internalKey>
    <description><![CDATA[Checks for bitwise operations in conditionals, if you need to do a bitwise operation then it is best practive to extract a temp variable.]]></description>
    <tag>basic</tag>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.basic.HardCodedWindowsFileSeparatorRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Hard Coded Windows File Separator]]></name>
    <internalKey><![CDATA[HardCodedWindowsFileSeparator]]></internalKey>
    <description><![CDATA[This rule finds usages of a Windows file separator within the constructor call of a File object. It is better to use the Unix file separator or use the File.separator constant.]]></description>
    <tag>basic</tag>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.basic.RandomDoubleCoercedToZeroRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Random Double Coerced To Zero]]></name>
    <internalKey><![CDATA[RandomDoubleCoercedToZero]]></internalKey>
    <description><![CDATA[The Math.random() method returns a double result greater than or equal to 0.0 and less than 1.0. If you coerce this result into an Integer or int, then it is coerced to zero. Casting the result to int, or assigning it to an int field is probably a bug.]]></description>
    <tag>basic</tag>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.basic.HardCodedWindowsRootDirectoryRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Hard Coded Windows Root Directory]]></name>
    <internalKey><![CDATA[HardCodedWindowsRootDirectory]]></internalKey>
    <description><![CDATA[This rule find cases where a <em>File</em> object is constructed with a windows-based path. This is not portable, and using the <em>File.listRoots()</em> method is a better alternative.]]></description>
    <tag>basic</tag>
  </rule>

  <!-- since 0.17 -->
  <rule>
    <key>org.codenarc.rule.basic.AssertWithinFinallyBlockRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Assert Within Finally Block]]></name>
    <internalKey><![CDATA[AssertWithinFinallyBlock]]></internalKey>
    <description><![CDATA[Checks for <em>assert</em> statements within a <em>finally</em> block. An <em>assert</em> can throw an exception, hiding the original exception, if there is one.]]></description>
    <tag>basic</tag>
  </rule>

  <!-- since 0.17 -->
  <rule>
    <key>org.codenarc.rule.basic.ConstantAssertExpressionRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Constant Assert Expression]]></name>
    <internalKey><![CDATA[ConstantAssertExpression]]></internalKey>
    <description><![CDATA[Checks for <em>assert</em> statements where the assert boolean condition expression is a constant or literal value.]]></description>
    <tag>basic</tag>
  </rule>

  <!-- since 0.17 -->
  <rule>
    <key>org.codenarc.rule.basic.BrokenNullCheckRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Broken Null Check]]></name>
    <internalKey><![CDATA[BrokenNullCheck]]></internalKey>
    <description><![CDATA[Looks for faulty checks for null that can cause a <em>NullPointerException</em>.]]></description>
    <tag>basic</tag>
  </rule>

  <!-- since 0.19 -->
  <rule>
    <key>org.codenarc.rule.basic.EmptyClassRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Empty Class]]></name>
    <internalKey><![CDATA[EmptyClass]]></internalKey>
    <description><![CDATA[Reports classes without methods, fields or properties. Why would you need a class like this?]]></description>
    <tag>basic</tag>
  </rule>

  <!-- since 0.21 -->
  <rule>
    <key>org.codenarc.rule.basic.MultipleUnaryOperatorsRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Multiple Unary Operators]]></name>
    <internalKey><![CDATA[MultipleUnaryOperators]]></internalKey>
    <description><![CDATA[Checks for multiple consecutive unary operators. These are confusing, and are likely typos and bugs.]]></description>
    <tag>basic</tag>
  </rule>

  <!-- serialization rules -->

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.serialization.SerialVersionUIDRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Serial Version UID]]></name>
    <internalKey><![CDATA[SerialVersionUID]]></internalKey>
    <description><![CDATA[A serialVersionUID is normally intended to be used with Serialization. It needs to be of type long, static, and final. Also, it should have a visibility modifier such as public or private. Providing no modifier creates a Property and Groovy generates a getter, which is probably not intended.]]></description>
    <tag>serialization</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.serialization.SerializableClassMustDefineSerialVersionUIDRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Serializable Class Must Define Serial Version UID]]></name>
    <internalKey><![CDATA[SerializableClassMustDefineSerialVersionUID]]></internalKey>
    <description><![CDATA[Classes that implement Serializable should define a serialVersionUID. If you don't define serialVersionUID, the system will make one by hashing most of your class's features. Then if you change anything, the UID will change and Java won't let you reload old data. ]]></description>
    <tag>serialization</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.serialization.SerialPersistentFieldsRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Serial Persistent Fields]]></name>
    <internalKey><![CDATA[SerialPersistentFields]]></internalKey>
    <description><![CDATA[To use a Serializable object's serialPersistentFields correctly, it must be declared private, static, and final.]]></description>
    <tag>serialization</tag>
  </rule>

  <!-- since 0.19 -->
  <rule>
    <key>org.codenarc.rule.serialization.EnumCustomSerializationIgnoredRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Enum Custom Serialization Ignored]]></name>
    <internalKey><![CDATA[EnumCustomSerializationIgnored]]></internalKey>
    <description><![CDATA[Checks for enums that define writeObject() or writeReplace() methods, or declare serialPersistentFields or serialVersionUID fields, all of which are ignored for enums.]]></description>
    <tag>serialization</tag>
  </rule>

  <!-- braces rules -->

  <rule>
    <key>org.codenarc.rule.braces.IfStatementBracesRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[If Statement Braces]]></name>
    <internalKey><![CDATA[IfStatementBraces]]></internalKey>
    <description><![CDATA[Use braces for <em>if</em> statements, even for a single statement.]]></description>
    <tag>braces</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.braces.ElseBlockBracesRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Else Block Braces]]></name>
    <internalKey><![CDATA[ElseBlockBraces]]></internalKey>
    <description><![CDATA[Use braces for <em>else</em> blocks, even for a single statement. By default, braces are not required for an <em>else</em> if it is followed immediately by an <em>if</em>. Set the <em>bracesRequiredForElseIf</em> property to true to require braces is that situation as well.]]></description>
    <tag>braces</tag>
    <param>
      <key>bracesRequiredForElseIf</key>
      <defaultValue>false</defaultValue>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.braces.ForStatementBracesRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[For Statement Braces]]></name>
    <internalKey><![CDATA[ForStatementBraces]]></internalKey>
    <description><![CDATA[Use braces for <em>for</em> statements, even for a single statement.]]></description>
    <tag>braces</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.braces.WhileStatementBracesRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[While Statement Braces]]></name>
    <internalKey><![CDATA[WhileStatementBraces]]></internalKey>
    <description><![CDATA[Use braces for <em>while</em> statements, even for a single statement.]]></description>
    <tag>braces</tag>
  </rule>

  <!-- concurrency rules -->

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.concurrency.BusyWaitRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Busy Wait]]></name>
    <internalKey><![CDATA[BusyWait]]></internalKey>
    <description><![CDATA[Busy waiting (forcing a Thread.sleep() while waiting on a condition) should be avoided. Prefer using the gate and barrier objects in the java.util.concurrent package.]]></description>
    <tag>concurrency</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.concurrency.DoubleCheckedLockingRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Double Checked Locking]]></name>
    <internalKey><![CDATA[DoubleCheckedLocking]]></internalKey>
    <description><![CDATA[This rule detects double checked locking, where a 'lock hint' is tested for null before initializing an object within a synchronized block. Double checked locking does not guarantee correctness and is an anti-pattern.]]></description>
    <tag>concurrency</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.concurrency.InconsistentPropertyLockingRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Inconsistent Property Locking]]></name>
    <internalKey><![CDATA[InconsistentPropertyLocking]]></internalKey>
    <description><![CDATA[Class contains similarly-named get and set methods where one method of the pair is marked either @WithReadLock or @WithWriteLock and the other is not locked at all.]]></description>
    <tag>concurrency</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.concurrency.InconsistentPropertySynchronizationRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Inconsistent Property Synchronization]]></name>
    <internalKey><![CDATA[InconsistentPropertySynchronization]]></internalKey>
    <description><![CDATA[Class contains similarly-named get and set methods where the set method is synchronized and the get method is not, or the get method is synchronized and the set method is not.]]></description>
    <tag>concurrency</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.concurrency.NestedSynchronizationRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Nested Synchronization]]></name>
    <internalKey><![CDATA[NestedSynchronization]]></internalKey>
    <description><![CDATA[Nested synchronized statements should be avoided. Nested synchronized statements are either useless (if the lock objects are identical) or prone to deadlock.]]></description>
    <tag>concurrency</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.concurrency.StaticCalendarFieldRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Static Calendar Field]]></name>
    <internalKey><![CDATA[StaticCalendarField]]></internalKey>
    <description><![CDATA[<em>Calendar</em> objects should not be used as static fields. <em>Calendars</em> are inherently unsafe for multihtreaded use. Sharing a single instance across thread boundaries without proper synchronization will result in erratic behavior of the application.]]></description>
    <tag>concurrency</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.concurrency.StaticDateFormatFieldRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Static Date Format Field]]></name>
    <internalKey><![CDATA[StaticDateFormatField]]></internalKey>
    <description><![CDATA[<em>DateFormat</em> objects should not be used as static fields. <em>DateFormat</em> are inherently unsafe for multithreaded use. Sharing a single instance across thread boundaries without proper synchronization will result in erratic behavior of the application.]]></description>
    <tag>concurrency</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.concurrency.StaticMatcherFieldRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Static Matcher Field]]></name>
    <internalKey><![CDATA[StaticMatcherField]]></internalKey>
    <description><![CDATA[<em>Matcher</em> objects should not be used as static fields. <em>Matcher</em> instances are inherently unsafe for multithreaded use. Sharing a single instance across thread boundaries without proper synchronization will result in erratic behavior of the application.]]></description>
    <tag>concurrency</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.concurrency.SynchronizedMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Synchronized Method]]></name>
    <internalKey><![CDATA[SynchronizedMethod]]></internalKey>
    <description><![CDATA[This rule reports uses of the <em>synchronized</em> keyword on methods. Synchronized methods are the same as synchronizing on 'this', which effectively make your synchronization policy public and modifiable by other objects. To avoid possibilities of deadlock, it is better to synchronize on internal objects.]]></description>
    <tag>concurrency</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.concurrency.SynchronizedOnGetClassRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Synchronized On Get Class]]></name>
    <internalKey><![CDATA[SynchronizedOnGetClass]]></internalKey>
    <description><![CDATA[Synchronization on getClass rather than class literal. This instance method synchronizes on this.getClass(). If this class is subclassed, subclasses will synchronize on the class object for the subclass, which isn't likely what was intended.]]></description>
    <tag>concurrency</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.concurrency.SynchronizedOnBoxedPrimitiveRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Synchronized On Boxed Primitive]]></name>
    <internalKey><![CDATA[SynchronizedOnBoxedPrimitive]]></internalKey>
    <description><![CDATA[The code synchronizes on a boxed primitive constant, such as an Integer. Since Integer objects can be cached and shared, this code could be synchronizing on the same object as other, unrelated code, leading to unresponsiveness and possible deadlock]]></description>
    <tag>concurrency</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.concurrency.SynchronizedOnStringRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Synchronized On String]]></name>
    <internalKey><![CDATA[SynchronizedOnString]]></internalKey>
    <description><![CDATA[Synchronization on a String field can lead to deadlock because Strings are interned by the JVM and can be shared.]]></description>
    <tag>concurrency</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.concurrency.SynchronizedOnThisRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Synchronized On This]]></name>
    <internalKey><![CDATA[SynchronizedOnThis]]></internalKey>
    <description><![CDATA[This rule reports uses of the <em>synchronized</em> blocks where the synchronization reference is 'this'. Doing this effectively makes your synchronization policy public and modifiable by other objects. To avoid possibilities of deadlock, it is better to synchronize on internal objects.]]></description>
    <tag>concurrency</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.concurrency.SynchronizedReadObjectMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Synchronized Read Object Method]]></name>
    <internalKey><![CDATA[SynchronizedReadObjectMethod]]></internalKey>
    <description><![CDATA[Catches Serializable classes that define a synchronized readObject method. By definition, an object created by deserialization is only reachable by one thread, and thus there is no need for readObject() to be synchronized. If the readObject() method itself is causing the object to become visible to another thread, that is an example of very dubious coding style.]]></description>
    <tag>concurrency</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.concurrency.SynchronizedOnReentrantLockRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Synchronized On Reentrant Lock]]></name>
    <internalKey><![CDATA[SynchronizedOnReentrantLock]]></internalKey>
    <description><![CDATA[Synchronizing on a ReentrantLock field is almost never the intended usage. A ReentrantLock should be obtained using the lock() method and released in a finally block using the unlock() method.]]></description>
    <tag>concurrency</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.concurrency.SystemRunFinalizersOnExitRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[System Run Finalizers On Exit]]></name>
    <internalKey><![CDATA[SystemRunFinalizersOnExit]]></internalKey>
    <description><![CDATA[Method calls to <em>System.runFinalizersOnExit()</em> should not be allowed. This method is inherently non-thread-safe, may result in data corruption, deadlock, and may effect parts of the program far removed from it's call point. It is deprecated, and it's use strongly discouraged.]]></description>
    <tag>concurrency</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.concurrency.ThreadGroupRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Thread Group]]></name>
    <internalKey><![CDATA[ThreadGroup]]></internalKey>
    <description><![CDATA[Avoid using ThreadGroup; although it is intended to be used in a threaded environment it contains methods that are not thread safe.]]></description>
    <tag>concurrency</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.concurrency.ThreadLocalNotStaticFinalRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Thread Local Not Static Final]]></name>
    <internalKey><![CDATA[ThreadLocalNotStaticFinal]]></internalKey>
    <description><![CDATA[<em>ThreadLocal</em> fields should be <em>static</em> and <em>final</em>. In the most common case a <em>java.lang.ThreadLocal</em> instance associates state with a thread. A non-<em>static</em> non-<em>final</em> <em>java.lang.ThreadLocal</em> field associates state with an instance-thread combination. This is seldom necessary and often a bug which can cause memory leaks and possibly incorrect behavior.]]></description>
    <tag>concurrency</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.concurrency.ThreadYieldRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Thread Yield]]></name>
    <internalKey><![CDATA[ThreadYield]]></internalKey>
    <description><![CDATA[Method calls to <em>Thread.yield()</em> should not be allowed. This method has no useful guaranteed semantics, and is often used by inexperienced programmers to mask race conditions.]]></description>
    <tag>concurrency</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.concurrency.UseOfNotifyMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Use Of Notify Method]]></name>
    <internalKey><![CDATA[UseOfNotifyMethod]]></internalKey>
    <description><![CDATA[This code calls notify() rather than notifyAll(). Java monitors are often used for multiple conditions. Calling notify() only wakes up one thread, meaning that the thread woken up might not be the one waiting for the condition that the caller just satisfied.]]></description>
    <tag>concurrency</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.concurrency.VolatileArrayFieldRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Volatile Array Field]]></name>
    <internalKey><![CDATA[VolatileArrayField]]></internalKey>
    <description><![CDATA[Volatile array fields are unsafe because the contents of the array are not treated as volatile. Changing the entire array reference is visible to other threads, but changing an array element is not.]]></description>
    <tag>concurrency</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.concurrency.VolatileLongOrDoubleFieldRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Volatile Long Or Double Field]]></name>
    <internalKey><![CDATA[VolatileLongOrDoubleField]]></internalKey>
    <description><![CDATA[Long or double fields should not be declared as <em>volatile</em>. Java specifies that reads and writes from such fields are atomic, but many JVM's have violated this specification. Unless you are certain of your JVM, it is better to synchronize access to such fields rather than declare them <em>volatile</em>. This rule flags fields marked <em>volatile</em> when their type is double or long or the name of their type is "Double" or "Long".]]></description>
    <tag>concurrency</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.concurrency.WaitOutsideOfWhileLoopRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Wait Outside Of While Loop]]></name>
    <internalKey><![CDATA[WaitOutsideOfWhileLoop]]></internalKey>
    <description><![CDATA[Calls to <em>Object.wait()</em> must be within a <em>while</em> loop. Consider using the Java concurrency utilities instead of <em>wait()</em> and <em>notify()</em>.]]></description>
    <tag>concurrency</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.concurrency.StaticConnectionRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Static Connection]]></name>
    <internalKey><![CDATA[StaticConnection]]></internalKey>
    <description><![CDATA[Creates violations when a java.sql.Connection object is used as a static field. Database connections stored in static fields will be shared between threads, which is unsafe and can lead to race conditions.]]></description>
    <tag>concurrency</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.concurrency.StaticSimpleDateFormatFieldRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Static Simple Date Format Field]]></name>
    <internalKey><![CDATA[StaticSimpleDateFormatField]]></internalKey>
    <description><![CDATA[<em>SimpleDateFormat</em> objects should not be used as <em>static</em> fields. <em>SimpleDateFormat</em> are inherently unsafe for multi-threaded use. Sharing a single instance across thread boundaries without proper synchronization will result in erratic behavior of the application.]]></description>
    <tag>concurrency</tag>
  </rule>

  <!-- since 0.19 -->
  <rule>
    <key>org.codenarc.rule.concurrency.ThisReferenceEscapesConstructorRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[This Reference Escapes Constructor]]></name>
    <internalKey><![CDATA[ThisReferenceEscapesConstructor]]></internalKey>
    <description><![CDATA[Reports constructors passing the 'this' reference to other methods. This equals exposing a half-baked objects and can lead to race conditions during initialization. For reference, see <a href='http://www.slideshare.net/alexmiller/java-concurrency-gotchas-3666977/38'>Java Concurrency Gotchas</a> by Alex Miller and <a href='http://www.ibm.com/developerworks/java/library/j-jtp0618/index.html'>Java theory and practice: Safe construction techniques</a> by Brian Goetz.]]></description>
    <tag>concurrency</tag>
  </rule>

  <!-- design rules -->

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.design.BooleanMethodReturnsNullRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Boolean Method Returns Null]]></name>
    <internalKey><![CDATA[BooleanMethodReturnsNull]]></internalKey>
    <description><![CDATA[Method with Boolean return type returns explicit null. A method that returns either Boolean.TRUE, Boolean.FALSE or null is an accident waiting to happen. This method can be invoked as though it returned a value of type boolean, and the compiler will insert automatic unboxing of the Boolean value. If a null value is returned, this will result in a NullPointerException.]]></description>
    <tag>design</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.design.CloneableWithoutCloneRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Cloneable Without Clone]]></name>
    <internalKey><![CDATA[CloneableWithoutClone]]></internalKey>
    <description><![CDATA[A class that implements <em>java.lang.Cloneable</em> should define a <em>clone()</em> method.]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.design.CompareToWithoutComparableRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Compare To Without Comparable]]></name>
    <internalKey><![CDATA[CompareToWithoutComparable]]></internalKey>
    <description><![CDATA[If you implement a compareTo method then you should also implement the Comparable interface. If you don't then you could possibly get an exception if the Groovy == operator is invoked on your object. This is an issue fixed in Groovy 1.8 but present in previous versions.]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.design.ReturnsNullInsteadOfEmptyArrayRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Returns Null Instead Of Empty Array]]></name>
    <internalKey><![CDATA[ReturnsNullInsteadOfEmptyArray]]></internalKey>
    <description><![CDATA[Consider returning a zero length array rather than null. It is often a better design to return a length zero array rather than a null reference to indicate that there are no results (i.e., an empty list of results). This way, no explicit check for null is needed by clients of the method.]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.design.ReturnsNullInsteadOfEmptyCollectionRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Returns Null Instead Of Empty Collection]]></name>
    <internalKey><![CDATA[ReturnsNullInsteadOfEmptyCollection]]></internalKey>
    <description><![CDATA[Consider returning a zero length collection rather than null. It is often a better design to return a length zero collection rather than a null reference to indicate that there are no results (i.e., an empty list of results). This way, no explicit check for null is needed by clients of the method.]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.design.SimpleDateFormatMissingLocaleRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Simple Date Format Missing Locale]]></name>
    <internalKey><![CDATA[SimpleDateFormatMissingLocale]]></internalKey>
    <description><![CDATA[Be sure to specify a Locale when creating a new instance of SimpleDateFormat; the class is locale-sensitive. If you instantiate SimpleDateFormat without a Locale parameter, it will format the date and time according to the default Locale. Both the pattern and the Locale determine the format. For the same pattern, SimpleDateFormat may format a date and time differently if the Locale varies.]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.design.AbstractClassWithoutAbstractMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Abstract Class Without Abstract Method]]></name>
    <internalKey><![CDATA[AbstractClassWithoutAbstractMethod]]></internalKey>
    <description><![CDATA[The abstract class does not contain any abstract methods. An abstract class suggests an incomplete implementation, which is to be completed by subclasses implementing the abstract methods. If the class is intended to be used as a base class only (not to be instantiated direcly) a protected constructor can be provided prevent direct instantiation.]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.design.CloseWithoutCloseableRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Close Without Closeable]]></name>
    <internalKey><![CDATA[CloseWithoutCloseable]]></internalKey>
    <description><![CDATA[If a class defines a "void close()" then that class should implement java.io.Closeable.]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.design.ConstantsOnlyInterfaceRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Constants Only Interface]]></name>
    <internalKey><![CDATA[ConstantsOnlyInterface]]></internalKey>
    <description><![CDATA[An interface should be used only to model a behaviour of a class: using an interface as a container of constants is a poor usage pattern.]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.design.EmptyMethodInAbstractClassRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Empty Method In Abstract Class]]></name>
    <internalKey><![CDATA[EmptyMethodInAbstractClass]]></internalKey>
    <description><![CDATA[An empty method in an abstract class should be abstract instead, as developer may rely on this empty implementation rather than code the appropriate one.]]></description>
    <tag>design</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.design.ImplementationAsTypeRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Implementation As Type]]></name>
    <internalKey><![CDATA[ImplementationAsType]]></internalKey>
    <description><![CDATA[Checks for use of a predefined set of concrete classes (e.g. <em>ArrayList</em>, <em>Hashtable</em>, <em>ConcurrentHashMap</em>) when specifying the type of a method parameter, closure parameter, constructor parameter, method return type or field type. The associated interfaces should be used to specify the type instead.]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.design.FinalClassWithProtectedMemberRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Final Class With Protected Member]]></name>
    <internalKey><![CDATA[FinalClassWithProtectedMember]]></internalKey>
    <description><![CDATA[This rule finds classes marked final that contain protected methods. If a class is final then it may not be subclassed, and there is therefore no point in having a method with protected visibility. Either the class should not be final or the method should be private or protected.]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.design.PublicInstanceFieldRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Public Instance Field]]></name>
    <internalKey><![CDATA[PublicInstanceField]]></internalKey>
    <description><![CDATA[Using public fields is considered to be a bad design. Use properties instead.]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.design.StatelessSingletonRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Stateless Singleton]]></name>
    <internalKey><![CDATA[StatelessSingleton]]></internalKey>
    <description><![CDATA[There is no point in creating a stateless Singleton because there is nothing within the class that needs guarding and no side effects to calling the constructor. Just create new instances of the object or write a Utility class with static methods.]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.design.AbstractClassWithPublicConstructorRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Abstract Class With Public Constructor]]></name>
    <internalKey><![CDATA[AbstractClassWithPublicConstructor]]></internalKey>
    <description><![CDATA[Checks for <em>abstract</em> classes that define a public constructor, which is useless and confusing.]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 0.16 -->
  <rule>
    <key>org.codenarc.rule.design.BuilderMethodWithSideEffectsRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Builder Method With Side Effects]]></name>
    <internalKey><![CDATA[BuilderMethodWithSideEffects]]></internalKey>
    <description><![CDATA[A builder method is defined as one that creates objects. As such, they should never be of void return type. If a method is named build, create, or make, then it should always return a value.]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 0.17 -->
  <rule>
    <key>org.codenarc.rule.design.PrivateFieldCouldBeFinalRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Private Field Could Be Final]]></name>
    <internalKey><![CDATA[PrivateFieldCouldBeFinal]]></internalKey>
    <description><![CDATA[Checks for <em>private</em> fields that are only set within a constructor or field initializer. Such fields can safely be made <em>final</em>.]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 0.19 -->
  <rule>
    <key>org.codenarc.rule.design.CloneWithoutCloneableRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Clone Without Cloneable]]></name>
    <internalKey><![CDATA[CloneWithoutCloneable]]></internalKey>
    <description><![CDATA[The method clone() should only be declared if the class implements the Cloneable interface.]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 0.20 -->
  <rule>
    <key>org.codenarc.rule.design.LocaleSetDefaultRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Locale Set Default]]></name>
    <internalKey><![CDATA[LocaleSetDefault]]></internalKey>
    <description><![CDATA[Checks for calls to <em>Locale.setDefault()</em>, which sets the Locale across the entire JVM.]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 0.21 -->
  <rule>
    <key>org.codenarc.rule.design.ToStringReturnsNullRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[To String Returns Null]]></name>
    <internalKey><![CDATA[ToStringReturnsNull]]></internalKey>
    <description><![CDATA[Checks for <em>toString()</em> methods that return null.]]></description>
    <tag>design</tag>
  </rule>

  <!-- since 0.22 -->
  <rule>
    <key>org.codenarc.rule.design.InstanceofRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Instanceof]]></name>
    <internalKey><![CDATA[Instanceof]]></internalKey>
    <description><![CDATA[Checks for use of the <em>instanceof</em> operator. Use the <em>ignoreTypeNames</em> property to configure ignored type names.]]></description>
    <tag>design</tag>
    <param>
      <key>ignoreTypeNames</key>
      <defaultValue>*Exception</defaultValue>
    </param>
  </rule>

  <!-- since 0.23 -->
  <rule>
    <key>org.codenarc.rule.design.NestedForLoopRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Nested For Loop]]></name>
    <internalKey><![CDATA[NestedForLoop]]></internalKey>
    <description><![CDATA[Reports classes with nested for loops.]]></description>
    <tag>design</tag>
  </rule>

  <!-- dry rules -->

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.dry.DuplicateNumberLiteralRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Duplicate Number Literal]]></name>
    <internalKey><![CDATA[DuplicateNumberLiteral]]></internalKey>
    <description><![CDATA[Code containing number String literals can usually be improved by declaring the number as a constant field.  The <em>ignoreNumbers</em> property can optionally specify a comma-separated list of numbers to ignore.]]></description>
    <tag>dry</tag>
    <param>
      <key>ignoreNumbers</key>
      <defaultValue>0,1</defaultValue>
    </param>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.dry.DuplicateStringLiteralRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Duplicate String Literal]]></name>
    <internalKey><![CDATA[DuplicateStringLiteral]]></internalKey>
    <description><![CDATA[Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The <em>ignoreStrings</em> property can optionally specify a comma-separated list of Strings to ignore.]]></description>
    <tag>dry</tag>
    <param>
      <key>ignoreStrings</key>
    </param>
  </rule>

  <!-- since 0.16 -->
  <rule>
    <key>org.codenarc.rule.dry.DuplicateMapLiteralRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Duplicate Map Literal]]></name>
    <internalKey><![CDATA[DuplicateMapLiteral]]></internalKey>
    <description><![CDATA[Code containing duplicate <em>Map</em> literals can usually be improved by declaring the <em>Map</em> as a constant field.]]></description>
    <tag>dry</tag>
  </rule>

  <!-- since 0.16 -->
  <rule>
    <key>org.codenarc.rule.dry.DuplicateListLiteralRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Duplicate List Literal]]></name>
    <internalKey><![CDATA[DuplicateListLiteral]]></internalKey>
    <description><![CDATA[Code containing duplicate <em>List</em> literals can usually be improved by declaring the <em>List</em> as a constant field.]]></description>
    <tag>dry</tag>
  </rule>

  <!-- exceptions rules -->

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.exceptions.CatchArrayIndexOutOfBoundsExceptionRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Catch Array Index Out Of Bounds Exception]]></name>
    <internalKey><![CDATA[CatchArrayIndexOutOfBoundsException]]></internalKey>
    <description><![CDATA[Check the size of the array before accessing an array element rather than catching <em>ArrayIndexOutOfBoundsException</em>.]]></description>
    <tag>exceptions</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.exceptions.CatchErrorRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Catch Error]]></name>
    <internalKey><![CDATA[CatchError]]></internalKey>
    <description><![CDATA[Catching <em>Error</em> is dangerous; it can catch exceptions such as <em>ThreadDeath</em> and <em>OutOfMemoryError</em>.]]></description>
    <tag>exceptions</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.exceptions.CatchExceptionRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Catch Exception]]></name>
    <internalKey><![CDATA[CatchException]]></internalKey>
    <description><![CDATA[Catching <em>Exception</em> is often too broad or general. It should usually be restricted to framework or infrastructure code, rather than application code.]]></description>
    <tag>exceptions</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.exceptions.CatchIllegalMonitorStateExceptionRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Catch Illegal Monitor State Exception]]></name>
    <internalKey><![CDATA[CatchIllegalMonitorStateException]]></internalKey>
    <description><![CDATA[Dubious catching of IllegalMonitorStateException. IllegalMonitorStateException is generally only thrown in case of a design flaw in your code (calling wait or notify on an object you do not hold a lock on).]]></description>
    <tag>exceptions</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.exceptions.CatchIndexOutOfBoundsExceptionRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Catch Index Out Of Bounds Exception]]></name>
    <internalKey><![CDATA[CatchIndexOutOfBoundsException]]></internalKey>
    <description><![CDATA[Check that an index is valid before accessing an indexed element rather than catching <em>IndexOutOfBoundsException</em>.]]></description>
    <tag>exceptions</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.exceptions.CatchNullPointerExceptionRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Catch Null Pointer Exception]]></name>
    <internalKey><![CDATA[CatchNullPointerException]]></internalKey>
    <description><![CDATA[Catching <em>NullPointerException</em> is never appropriate. It should be avoided in the first place with proper null checking, and it can mask underlying errors.]]></description>
    <tag>exceptions</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.exceptions.CatchRuntimeExceptionRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Catch Runtime Exception]]></name>
    <internalKey><![CDATA[CatchRuntimeException]]></internalKey>
    <description><![CDATA[Catching <em>RuntimeException</em> is often too broad or general. It should usually be restricted to framework or infrastructure code, rather than application code.]]></description>
    <tag>exceptions</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.exceptions.CatchThrowableRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Catch Throwable]]></name>
    <internalKey><![CDATA[CatchThrowable]]></internalKey>
    <description><![CDATA[Catching <em>Throwable</em> is dangerous; it can catch exceptions such as <em>ThreadDeath</em> and <em>OutOfMemoryError</em>.]]></description>
    <tag>exceptions</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.exceptions.ConfusingClassNamedExceptionRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Confusing Class Named Exception]]></name>
    <internalKey><![CDATA[ConfusingClassNamedException]]></internalKey>
    <description><![CDATA[This class is not derived from another exception, but ends with 'Exception'. This will be confusing to users of this class.]]></description>
    <tag>exceptions</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.exceptions.ExceptionExtendsErrorRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Exception Extends Error]]></name>
    <internalKey><![CDATA[ExceptionExtendsError]]></internalKey>
    <description><![CDATA[Errors are system exceptions. Do not extend them.]]></description>
    <tag>exceptions</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.exceptions.MissingNewInThrowStatementRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Missing New In Throw Statement]]></name>
    <internalKey><![CDATA[MissingNewInThrowStatement]]></internalKey>
    <description><![CDATA[A common Groovy mistake when throwing exceptions is to forget the new keyword. For instance, "throw RuntimeException()" instead of "throw new RuntimeException()". If the error path is not unit tested then the production system will throw a Method Missing exception and hide the root cause. This rule finds constructs like "throw RuntimeException()" that look like a new keyword was meant to be used but forgotten.]]></description>
    <tag>exceptions</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.exceptions.ReturnNullFromCatchBlockRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Return Null From Catch Block]]></name>
    <internalKey><![CDATA[ReturnNullFromCatchBlock]]></internalKey>
    <description><![CDATA[Returning <em>null</em> from a catch block often masks errors and requires the client to handle error codes. In some coding styles this is discouraged.]]></description>
    <tag>exceptions</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.exceptions.ThrowErrorRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Throw Error]]></name>
    <internalKey><![CDATA[ThrowError]]></internalKey>
    <description><![CDATA[Checks for throwing an instance of <em>java.lang.Error</em>.]]></description>
    <tag>exceptions</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.exceptions.ThrowExceptionRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Throw Exception]]></name>
    <internalKey><![CDATA[ThrowException]]></internalKey>
    <description><![CDATA[Checks for throwing an instance of <em>java.lang.Exception</em>.]]></description>
    <tag>exceptions</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.exceptions.ThrowNullPointerExceptionRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Throw Null Pointer Exception]]></name>
    <internalKey><![CDATA[ThrowNullPointerException]]></internalKey>
    <description><![CDATA[Checks for throwing an instance of <em>java.lang.NullPointerException</em>.]]></description>
    <tag>exceptions</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.exceptions.ThrowRuntimeExceptionRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Throw Runtime Exception]]></name>
    <internalKey><![CDATA[ThrowRuntimeException]]></internalKey>
    <description><![CDATA[Checks for throwing an instance of <em>java.lang.RuntimeException</em>.]]></description>
    <tag>exceptions</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.exceptions.ThrowThrowableRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Throw Throwable]]></name>
    <internalKey><![CDATA[ThrowThrowable]]></internalKey>
    <description><![CDATA[Checks for throwing an instance of <em>java.lang.Throwable</em>.]]></description>
    <tag>exceptions</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.exceptions.SwallowThreadDeathRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Swallow Thread Death]]></name>
    <internalKey><![CDATA[SwallowThreadDeath]]></internalKey>
    <description><![CDATA[Checks for code that catches ThreadDeath without re-throwing it.]]></description>
    <tag>exceptions</tag>
  </rule>

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.exceptions.ExceptionNotThrownRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Exception Not Thrown]]></name>
    <internalKey><![CDATA[ExceptionNotThrown]]></internalKey>
    <description><![CDATA[Checks for an exception constructor call without a <em>throw</em> as the last statement within a catch block.]]></description>
    <tag>exceptions</tag>
  </rule>

  <!-- since 0.21 -->
  <rule>
    <key>org.codenarc.rule.exceptions.ExceptionExtendsThrowableRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Exception Extends Throwable]]></name>
    <internalKey><![CDATA[ExceptionExtendsThrowable]]></internalKey>
    <description><![CDATA[Checks for classes that extend <em>java.lang.Throwable</em>. Custom exception classes should subclass <em>java.lang.Exception</em> or one of its descendants.]]></description>
    <tag>exceptions</tag>
  </rule>

  <!-- generic rules -->

  <rule>
    <key>org.codenarc.rule.generic.IllegalRegexRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Illegal Regex]]></name>
    <internalKey><![CDATA[IllegalRegex]]></internalKey>
    <description><![CDATA[Checks for a specified illegal regular expression within the source code. The <em>regex</em> property specifies the regular expression to check for. It is required and cannot be null or empty.]]></description>
    <tag>generic</tag>
    <param>
      <key>regex</key>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.generic.RequiredRegexRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Required Regex]]></name>
    <internalKey><![CDATA[RequiredRegex]]></internalKey>
    <description><![CDATA[Checks for a specified regular expression that must exist within the source code. The <em>regex</em> property specifies the regular expression to check for. It is required and cannot be null or empty.]]></description>
    <tag>generic</tag>
    <param>
      <key>regex</key>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.generic.RequiredStringRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Required String]]></name>
    <internalKey><![CDATA[RequiredString]]></internalKey>
    <description><![CDATA[Checks for a specified text string that must exist within the source code. The <em>string</em> property specifies the String to check for. It is required and cannot be null or empty.]]></description>
    <tag>generic</tag>
    <param>
      <key>string</key>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.generic.StatelessClassRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Stateless Class]]></name>
    <internalKey><![CDATA[StatelessClass]]></internalKey>
    <description><![CDATA[Checks for fields on classes that should remain "stateless" and reentrant. The <em>ignoreFieldNames</em> property specifies one or more field names that should be ignored. The <em>ignoreFieldTypes</em> property specifies one or more field type names that should be ignored. Both can optionally contain wildcard characters ('*' or '?').]]></description>
    <tag>generic</tag>
    <param>
      <key>ignoreFieldNames</key>
    </param>
    <param>
      <key>ignoreFieldTypes</key>
    </param>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.generic.IllegalPackageReferenceRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Illegal Package Reference]]></name>
    <internalKey><![CDATA[IllegalPackageReference]]></internalKey>
    <description><![CDATA[Checks for reference to any of the packages configured in <em>packageNames</em>.]]></description>
    <tag>generic</tag>
    <param>
      <key>packageNames</key>
    </param>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.generic.IllegalClassReferenceRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Illegal Class Reference]]></name>
    <internalKey><![CDATA[IllegalClassReference]]></internalKey>
    <description><![CDATA[Checks for reference to any of the classes configured in <em>classNames</em>.]]></description>
    <tag>generic</tag>
    <param>
      <key>classNames</key>
    </param>
  </rule>

  <!-- since 0.19 -->
  <rule>
    <key>org.codenarc.rule.generic.IllegalClassMemberRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Illegal Class Member]]></name>
    <internalKey><![CDATA[IllegalClassMember]]></internalKey>
    <description><![CDATA[Checks for classes containing fields/properties/methods matching configured illegal member modifiers or not matching any of the configured allowed member modifiers.]]></description>
    <tag>generic</tag>
  </rule>

  <!-- since 0.20 -->
  <rule>
    <key>org.codenarc.rule.generic.IllegalStringRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Illegal String]]></name>
    <internalKey><![CDATA[IllegalString]]></internalKey>
    <description><![CDATA[Checks for a specified illegal string within the source code.]]></description>
    <tag>generic</tag>
  </rule>

  <!-- since 0.21 -->
  <rule>
    <key>org.codenarc.rule.generic.IllegalSubclassRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Illegal Subclass]]></name>
    <internalKey><![CDATA[IllegalSubclass]]></internalKey>
    <description><![CDATA[Checks for classes that extend one of the specified set of illegal superclasses configured in <em>superclassNames</em>.]]></description>
    <tag>generic</tag>
    <param>
      <key>superclassNames</key>
    </param>
  </rule>

  <!-- grails rules -->

  <rule>
    <key>org.codenarc.rule.grails.GrailsPublicControllerMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Grails Public Controller Method]]></name>
    <internalKey><![CDATA[GrailsPublicControllerMethod]]></internalKey>
    <description><![CDATA[Checks for <em>public</em> methods on Grails controller classes. Static methods are ignored.]]></description>
    <tag>grails</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.grails.GrailsSessionReferenceRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Grails Session Reference]]></name>
    <internalKey><![CDATA[GrailsSessionReference]]></internalKey>
    <description><![CDATA[Checks for references to the <em>session</em> object from within Grails controller and taglib classes. [DEPRECATED]]]></description>
    <tag>grails</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.grails.GrailsServletContextReferenceRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Grails Servlet Context Reference]]></name>
    <internalKey><![CDATA[GrailsServletContextReference]]></internalKey>
    <description><![CDATA[Checks for references to the <em>servletContext</em> object from within Grails controller and taglib classes.]]></description>
    <tag>grails</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.grails.GrailsStatelessServiceRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Grails Stateless Service]]></name>
    <internalKey><![CDATA[GrailsStatelessService]]></internalKey>
    <description><![CDATA[Checks for fields on Grails service classes. Grails service classes are singletons, by default, and so they should be reentrant and typically stateless. The <em>ignoreFieldNames</em> property specifies one or more field names that should be ignored. The <em>ignoreFieldTypes</em> property specifies one or more field type names that should be ignored. Both can optionally contain wildcard characters ('*' or '?').]]></description>
    <tag>grails</tag>
    <param>
      <key>ignoreFieldNames</key>
    </param>
    <param>
      <key>ignoreFieldTypes</key>
    </param>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.grails.GrailsDomainHasToStringRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Grails Domain Has To String]]></name>
    <internalKey><![CDATA[GrailsDomainHasToString]]></internalKey>
    <description><![CDATA[Checks that Grails domain classes redefine toString()]]></description>
    <tag>grails</tag>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.grails.GrailsDomainHasEqualsRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Grails Domain Has Equals]]></name>
    <internalKey><![CDATA[GrailsDomainHasEquals]]></internalKey>
    <description><![CDATA[Checks that Grails domain classes redefine equals().]]></description>
    <tag>grails</tag>
  </rule>

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.grails.GrailsDuplicateMappingRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Grails Duplicate Mapping]]></name>
    <internalKey><![CDATA[GrailsDuplicateMapping]]></internalKey>
    <description><![CDATA[Check for duplicate name in a domain class mapping]]></description>
    <tag>grails</tag>
  </rule>

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.grails.GrailsDuplicateConstraintRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Grails Duplicate Constraint]]></name>
    <internalKey><![CDATA[GrailsDuplicateConstraint]]></internalKey>
    <description><![CDATA[Check for duplicate entry in domain class constraints]]></description>
    <tag>grails</tag>
  </rule>

  <!-- since 0.19 -->
  <rule>
    <key>org.codenarc.rule.grails.GrailsDomainReservedSqlKeywordNameRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Grails Domain Reserved Sql Keyword Name]]></name>
    <internalKey><![CDATA[GrailsDomainReservedSqlKeywordName]]></internalKey>
    <description><![CDATA[Forbids usage of SQL reserved keywords as class or field names in Grails domain classes. Naming a domain class (or its field) with such a keyword causes SQL schema creation errors and/or redundant table/column name mappings.]]></description>
    <tag>grails</tag>
  </rule>

  <!-- since 0.19 -->
  <rule>
    <key>org.codenarc.rule.grails.GrailsDomainWithServiceReferenceRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Grails Domain With Service Reference]]></name>
    <internalKey><![CDATA[GrailsDomainWithServiceReference]]></internalKey>
    <description><![CDATA[Checks that Grails domain classes do not have service classes injected.]]></description>
    <tag>grails</tag>
  </rule>

  <!-- since 0.21 -->
  <rule>
    <key>org.codenarc.rule.grails.GrailsMassAssignmentRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Grails Mass Assignment]]></name>
    <internalKey><![CDATA[GrailsMassAssignment]]></internalKey>
    <description><![CDATA[Untrusted input should not be allowed to set arbitrary object fields without restriction.]]></description>
    <tag>grails</tag>
  </rule>

  <!-- imports rules -->

  <rule>
    <key>org.codenarc.rule.imports.DuplicateImportRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Duplicate Import]]></name>
    <internalKey><![CDATA[DuplicateImport]]></internalKey>
    <description><![CDATA[Duplicate import statements are unnecessary.]]></description>
    <tag>imports</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.imports.ImportFromSamePackageRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Import From Same Package]]></name>
    <internalKey><![CDATA[ImportFromSamePackage]]></internalKey>
    <description><![CDATA[An import of a class that is within the same package is unnecessary.]]></description>
    <tag>imports</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.imports.UnnecessaryGroovyImportRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Groovy Import]]></name>
    <internalKey><![CDATA[UnnecessaryGroovyImport]]></internalKey>
    <description><![CDATA[A Groovy file does not need to include an import for classes from <em>java.lang</em>, <em>java.util</em>, <em>java.io</em>, <em>java.net</em>, <em>groovy.lang</em> and <em>groovy.util</em>, as well as the classes <em>java.math.BigDecimal</em> and <em>java.math.BigInteger</em>.]]></description>
    <tag>imports</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.imports.UnusedImportRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unused Import]]></name>
    <internalKey><![CDATA[UnusedImport]]></internalKey>
    <description><![CDATA[Imports for a class that is never referenced within the source file is unnecessary.]]></description>
    <tag>imports</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.imports.ImportFromSunPackagesRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Import From Sun Packages]]></name>
    <internalKey><![CDATA[ImportFromSunPackages]]></internalKey>
    <description><![CDATA[Avoid importing anything from the 'sun.*' packages. These packages are not portable and are likely to change.]]></description>
    <tag>imports</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.imports.MisorderedStaticImportsRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Misordered Static Imports]]></name>
    <internalKey><![CDATA[MisorderedStaticImports]]></internalKey>
    <description><![CDATA[Static imports should never be declared after nonstatic imports.]]></description>
    <tag>imports</tag>
  </rule>

  <!-- since 0.21 -->
  <rule>
    <key>org.codenarc.rule.imports.NoWildcardImportsRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[No Wildcard Imports]]></name>
    <internalKey><![CDATA[NoWildcardImports]]></internalKey>
    <description><![CDATA[Wildcard imports, static or otherwise, should not be used.]]></description>
    <tag>imports</tag>
  </rule>

  <!-- junit rules -->

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.junit.ChainedTestRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Chained Test]]></name>
    <internalKey><![CDATA[ChainedTest]]></internalKey>
    <description><![CDATA[A test method that invokes another test method is a chained test; the methods are dependent on one another. Tests should be isolated, and not be dependent on one another.]]></description>
    <tag>junit</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.junit.CoupledTestCaseRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Coupled Test Case]]></name>
    <internalKey><![CDATA[CoupledTestCase]]></internalKey>
    <description><![CDATA[This rule finds test cases that are coupled to other test cases, either by invoking static methods on another test case or by creating instances of another test case. If you require shared logic in test cases then extract that logic to a new class where it can properly be reused.]]></description>
    <tag>junit</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.junit.JUnitAssertAlwaysFailsRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[J Unit Assert Always Fails]]></name>
    <internalKey><![CDATA[JUnitAssertAlwaysFails]]></internalKey>
    <description><![CDATA[Checks for JUnit <em>assert()</em> method calls with constant arguments such that the assertion always fails. This includes: <em>assertTrue(false)</em>, <em>assertFalse(true)</em> and <em>assertNull(CONSTANT)</em>.]]></description>
    <tag>junit</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.junit.JUnitAssertAlwaysSucceedsRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[J Unit Assert Always Succeeds]]></name>
    <internalKey><![CDATA[JUnitAssertAlwaysSucceeds]]></internalKey>
    <description><![CDATA[Checks for JUnit <em>assert()</em> method calls with constant arguments such that the assertion always succeeds. This includes: <em>assertTrue(true)</em>, <em>assertFalse(false)</em> and <em>assertNull(null)</em>.]]></description>
    <tag>junit</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.junit.JUnitPublicNonTestMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[J Unit Public Non Test Method]]></name>
    <internalKey><![CDATA[JUnitPublicNonTestMethod]]></internalKey>
    <description><![CDATA[Checks if a JUnit test class contains public methods other than standard test methods, JUnit framework methods or methods with JUnit annotations.]]></description>
    <tag>junit</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.junit.JUnitSetUpCallsSuperRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[J Unit Set Up Calls Super]]></name>
    <internalKey><![CDATA[JUnitSetUpCallsSuper]]></internalKey>
    <description><![CDATA[Checks that if the JUnit <em>setUp()</em> method is defined, that it includes a call to <em>super.setUp()</em>.]]></description>
    <tag>junit</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.junit.JUnitStyleAssertionsRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[J Unit Style Assertions]]></name>
    <internalKey><![CDATA[JUnitStyleAssertions]]></internalKey>
    <description><![CDATA[This rule detects calling JUnit style assertions like <em>assertEquals</em>, <em>assertTrue</em>, <em>assertFalse</em>, <em>assertNull</em>, <em>assertNotNull</em>. Groovy 1.7 ships with a feature called the "power assert", which is an assert statement with better error reporting. This is preferable to the JUnit assertions.]]></description>
    <tag>junit</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.junit.JUnitTearDownCallsSuperRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[J Unit Tear Down Calls Super]]></name>
    <internalKey><![CDATA[JUnitTearDownCallsSuper]]></internalKey>
    <description><![CDATA[Checks that if the JUnit <em>tearDown()</em> method is defined, that it includes a call to <em>super.tearDown()</em>.]]></description>
    <tag>junit</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.junit.JUnitUnnecessarySetUpRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[J Unit Unnecessary Set Up]]></name>
    <internalKey><![CDATA[JUnitUnnecessarySetUp]]></internalKey>
    <description><![CDATA[Checks for JUnit <em>setUp()</em> methods that contain only a call to <em>super.setUp()</em>.]]></description>
    <tag>junit</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.junit.JUnitUnnecessaryTearDownRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[J Unit Unnecessary Tear Down]]></name>
    <internalKey><![CDATA[JUnitUnnecessaryTearDown]]></internalKey>
    <description><![CDATA[Checks for JUnit <em>tearDown()</em> methods that contain only a call to <em>super.tearDown()</em>.]]></description>
    <tag>junit</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.junit.UseAssertEqualsInsteadOfAssertTrueRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Use Assert Equals Instead Of Assert True]]></name>
    <internalKey><![CDATA[UseAssertEqualsInsteadOfAssertTrue]]></internalKey>
    <description><![CDATA[This rule detects JUnit assertions in object equality. These assertions should be made by more specific methods, like <em>assertEquals</em>.]]></description>
    <tag>junit</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.junit.UseAssertFalseInsteadOfNegationRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Use Assert False Instead Of Negation]]></name>
    <internalKey><![CDATA[UseAssertFalseInsteadOfNegation]]></internalKey>
    <description><![CDATA[In unit tests, if a condition is expected to be false then there is no sense using assertTrue with the negation operator. For instance, assertTrue(!condition) can always be simplified to assertFalse(condition)]]></description>
    <tag>junit</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.junit.UseAssertTrueInsteadOfAssertEqualsRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Use Assert True Instead Of Assert Equals]]></name>
    <internalKey><![CDATA[UseAssertTrueInsteadOfAssertEquals]]></internalKey>
    <description><![CDATA[This rule detects JUnit calling <em>assertEquals</em> where the first parameter is a boolean. These assertions should be made by more specific methods, like <em>assertTrue</em> or <em>assertFalse</em>.]]></description>
    <tag>junit</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.junit.UseAssertTrueInsteadOfNegationRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Use Assert True Instead Of Negation]]></name>
    <internalKey><![CDATA[UseAssertTrueInsteadOfNegation]]></internalKey>
    <description><![CDATA[In unit tests, if a condition is expected to be true then there is no sense using assertFalse with the negation operator. For instance, assertFalse(!condition) can always be simplified to assertTrue(condition)]]></description>
    <tag>junit</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.junit.UseAssertNullInsteadOfAssertEqualsRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Use Assert Null Instead Of Assert Equals]]></name>
    <internalKey><![CDATA[UseAssertNullInsteadOfAssertEquals]]></internalKey>
    <description><![CDATA[This rule detects JUnit calling <em>assertEquals</em> where the first or second parameter is null. These assertion should be made against the <em>assertNull</em> method instead.]]></description>
    <tag>junit</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.junit.UseAssertSameInsteadOfAssertTrueRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Use Assert Same Instead Of Assert True]]></name>
    <internalKey><![CDATA[UseAssertSameInsteadOfAssertTrue]]></internalKey>
    <description><![CDATA[This rule detects JUnit calling <em>assertTrue</em> where the first or second parameter is an Object#is() call testing for reference equality. These assertion should be made against the <em>assertSame</em> method instead.]]></description>
    <tag>junit</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.junit.JUnitFailWithoutMessageRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[J Unit Fail Without Message]]></name>
    <internalKey><![CDATA[JUnitFailWithoutMessage]]></internalKey>
    <description><![CDATA[This rule detects JUnit calling the <em>fail()</em> method without an argument. For better error reporting you should always provide a message.]]></description>
    <tag>junit</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.junit.JUnitTestMethodWithoutAssertRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[J Unit Test Method Without Assert]]></name>
    <internalKey><![CDATA[JUnitTestMethodWithoutAssert]]></internalKey>
    <description><![CDATA[This rule searches for test methods that do not contain assert statements. Either the test method is missing assert statements, which is an error, or the test method contains custom assert statements that do not follow a proper assert naming convention. Test methods are defined as public void methods that begin with the work test or have a @Test annotation. By default this rule applies to the default test class names, but this can be changed using the rule's applyToClassNames property.]]></description>
    <tag>junit</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.junit.UnnecessaryFailRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Unnecessary Fail]]></name>
    <internalKey><![CDATA[UnnecessaryFail]]></internalKey>
    <description><![CDATA[In a unit test, catching an exception and immediately calling Assert.fail() is pointless and hides the stack trace. It is better to rethrow the exception or not catch the exception at all.]]></description>
    <tag>junit</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.junit.SpockIgnoreRestUsedRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Spock Ignore Rest Used]]></name>
    <internalKey><![CDATA[SpockIgnoreRestUsed]]></internalKey>
    <description><![CDATA[If Spock's @IgnoreRest appears on any method, all non-annotated test methods are not executed. This behaviour is almost always unintended. It's fine to use @IgnoreRest locally during development, but when committing code, it should be removed.]]></description>
    <tag>junit</tag>
  </rule>

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.junit.JUnitLostTestRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[J Unit Lost Test]]></name>
    <internalKey><![CDATA[JUnitLostTest]]></internalKey>
    <description><![CDATA[Checks for classes that import JUnit 4 classes and contain a public, instance, void, no-arg method named test* that is not annotated with @Test.]]></description>
    <tag>junit</tag>
  </rule>

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.junit.JUnitUnnecessaryThrowsExceptionRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[J Unit Unnecessary Throws Exception]]></name>
    <internalKey><![CDATA[JUnitUnnecessaryThrowsException]]></internalKey>
    <description><![CDATA[Check for <em>throws</em> clauses on JUnit test methods. That is not necessary in Groovy.]]></description>
    <tag>junit</tag>
  </rule>

  <!-- since 0.19 -->
  <rule>
    <key>org.codenarc.rule.junit.JUnitPublicFieldRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[J Unit Public Field]]></name>
    <internalKey><![CDATA[JUnitPublicField]]></internalKey>
    <description><![CDATA[Checks for public field on a JUnit test class]]></description>
    <tag>junit</tag>
  </rule>

  <!-- since 0.19 -->
  <rule>
    <key>org.codenarc.rule.junit.JUnitAssertEqualsConstantActualValueRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[J Unit Assert Equals Constant Actual Value]]></name>
    <internalKey><![CDATA[JUnitAssertEqualsConstantActualValue]]></internalKey>
    <description><![CDATA[Reports usages of org.junit.Assert.assertEquals([message,] expected, actual) where the 'actual' parameter is a constant or a literal. Most likely it was intended to be the 'expected' value.]]></description>
    <tag>junit</tag>
  </rule>

  <!-- since 0.21 -->
  <rule>
    <key>org.codenarc.rule.junit.JUnitPublicPropertyRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[J Unit Public Property]]></name>
    <internalKey><![CDATA[JUnitPublicProperty]]></internalKey>
    <description><![CDATA[Checks for public properties defined on JUnit test classes. There should be no need to expose a public property on a test class.]]></description>
    <tag>junit</tag>
  </rule>

  <!-- logging rules -->

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.logging.LoggerForDifferentClassRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Logger For Different Class]]></name>
    <internalKey><![CDATA[LoggerForDifferentClass]]></internalKey>
    <description><![CDATA[Checks for instantiating a logger (<em>Log4J</em>, <em>SLF4J</em>, <em>Logback</em>, <em>Apache Commons Logging</em> or <em>Java Util Logging</em>) for a class other than the current class.]]></description>
    <tag>logging</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.logging.LoggingSwallowsStacktraceRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Logging Swallows Stacktrace]]></name>
    <internalKey><![CDATA[LoggingSwallowsStacktrace]]></internalKey>
    <description><![CDATA[If you are logging an exception then the proper API is to call error(Object, Throwable), which will log the message and the exception stack trace. If you call error(Object) then the stacktrace may not be logged.]]></description>
    <tag>logging</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.logging.LoggerWithWrongModifiersRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Logger With Wrong Modifiers]]></name>
    <internalKey><![CDATA[LoggerWithWrongModifiers]]></internalKey>
    <description><![CDATA[Logger objects should be declared private, static and final. If subclasses should have access to a Logger in a parent class then the Logger should be declared protected, non-static and final. This rule find loggers that are not declared with these modifiers.]]></description>
    <tag>logging</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.logging.MultipleLoggersRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Multiple Loggers]]></name>
    <internalKey><![CDATA[MultipleLoggers]]></internalKey>
    <description><![CDATA[This rule catches classes that have more than one logger object defined. Typically, a class has zero or one logger objects.]]></description>
    <tag>logging</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.logging.PrintlnRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Println]]></name>
    <internalKey><![CDATA[Println]]></internalKey>
    <description><![CDATA[Checks for calls to <em>this.print()</em>, <em>this.println()</em> or <em>this.printf()</em>.]]></description>
    <tag>logging</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.logging.PrintStackTraceRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Print Stack Trace]]></name>
    <internalKey><![CDATA[PrintStackTrace]]></internalKey>
    <description><![CDATA[Checks for calls to <em>printStackTrace()</em>.]]></description>
    <tag>logging</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.logging.SystemErrPrintRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[System Err Print]]></name>
    <internalKey><![CDATA[SystemErrPrint]]></internalKey>
    <description><![CDATA[Checks for calls to <em>System.err.print()</em>, <em>System.err.println()</em> or <em>System.err.printf()</em>.]]></description>
    <tag>logging</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.logging.SystemOutPrintRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[System Out Print]]></name>
    <internalKey><![CDATA[SystemOutPrint]]></internalKey>
    <description><![CDATA[Checks for calls to <em>System.out.print()</em>, <em>System.out.println()</em> or <em>System.out.printf()</em>.]]></description>
    <tag>logging</tag>
  </rule>

  <!-- naming rules -->

  <rule>
    <key>org.codenarc.rule.naming.AbstractClassNameRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Abstract Class Name]]></name>
    <internalKey><![CDATA[AbstractClassName]]></internalKey>
    <description><![CDATA[Verifies that the name of an abstract class matches a regular expression specified in the <em>regex</em> property. If that property is null or empty, then this rule is not applied (i.e., it does nothing). It defaults to null, so this rule must be explicitly configured to be active. This rule ignores interfaces.]]></description>
    <tag>naming</tag>
    <param>
      <key>regex</key>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.naming.ClassNameRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Class Name]]></name>
    <internalKey><![CDATA[ClassName]]></internalKey>
    <description><![CDATA[Verifies that the name of a class matches a regular expression. By default it checks that the class name starts with an uppercase letter and is followed by zero or more word characters (letters, numbers or underscores). The <em>regex</em> property specifies the regular expression used to validate the class name.]]></description>
    <tag>naming</tag>
    <param>
      <key>regex</key>
      <defaultValue>([A-Z]\w*\$?)*</defaultValue>
    </param>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.naming.ConfusingMethodNameRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Confusing Method Name]]></name>
    <internalKey><![CDATA[ConfusingMethodName]]></internalKey>
    <description><![CDATA[Checks for confusing method names. The referenced methods have names that differ only by capitalization. This is very confusing because if the capitalization were identical then one of the methods would override the other.]]></description>
    <tag>naming</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.naming.FieldNameRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Field Name]]></name>
    <internalKey><![CDATA[FieldName]]></internalKey>
    <description><![CDATA[Verifies that the name of each field matches a regular expression. By default it checks that non-'final' field names start with a lowercase letter and contains only letters or numbers, and 'final' field names start with an uppercase letter and contain only uppercase letters, numbers and underscores. The <em>regex</em> property specifies the default regular expression used to validate field names. The <em>finalRegex</em> property specifies the regular expression to validate 'final' field names. The <em>staticRegex</em> property specifies the regular expression to validate 'static' field names. The <em>staticFinalRegex</em> property specifies the regular expression to validate 'static final' field names.  The <em>ignoreFieldNames</em> propertycan specify field names that should be ignored, optionally containing wildcard characters ('*' or '?').]]></description>
    <tag>naming</tag>
    <param>
      <key>finalRegex</key>
    </param>
    <param>
      <key>ignoreFieldNames</key>
      <defaultValue>serialVersionUID</defaultValue>
    </param>
    <param>
      <key>staticFinalRegex</key>
      <defaultValue>[A-Z][A-Z0-9_]*</defaultValue>
    </param>
    <param>
      <key>regex</key>
      <defaultValue>[a-z][a-zA-Z0-9]*</defaultValue>
    </param>
    <param>
      <key>staticRegex</key>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.naming.InterfaceNameRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Interface Name]]></name>
    <internalKey><![CDATA[InterfaceName]]></internalKey>
    <description><![CDATA[Verifies that the name of an interface matches a regular expression specified in the <em>regex</em> property. If that property is null or empty, then this rule is not applied (i.e., it does nothing). It defaults to null, so this rule must be explicitly configured to be active.]]></description>
    <tag>naming</tag>
    <param>
      <key>regex</key>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.naming.MethodNameRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Method Name]]></name>
    <internalKey><![CDATA[MethodName]]></internalKey>
    <description><![CDATA[Verifies that the name of each method matches a regular expression. By default it checks that the method name starts with a lowercase letter. The <em>regex</em> property specifies the regular expression to check the method name against.  The <em>ignoreMethodNames</em> property can specify method names that should be ignored, optionally containing wildcard characters ('*' or '?').]]></description>
    <tag>naming</tag>
    <param>
      <key>regex</key>
      <defaultValue>[a-z]\w*</defaultValue>
    </param>
    <param>
      <key>ignoreMethodNames</key>
    </param>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.naming.ObjectOverrideMisspelledMethodNameRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Object Override Misspelled Method Name]]></name>
    <internalKey><![CDATA[ObjectOverrideMisspelledMethodName]]></internalKey>
    <description><![CDATA[Verifies that the names of the most commonly overridden methods of Object: <em>equals</em>, <em>hashCode</em> and <em>toString</em>, are correct.]]></description>
    <tag>naming</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.naming.PackageNameRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Package Name]]></name>
    <internalKey><![CDATA[PackageName]]></internalKey>
    <description><![CDATA[Verifies that the package name for a class matches a regular expression. By default it checks that the package name consists of only lowercase letters, separated by periods. The <em>regex</em> property specifies the regular expression used to validate the package name. The <em>packageNameRequired</em> property indicates whether a package name declaration is required for all classes.]]></description>
    <tag>naming</tag>
    <param>
      <key>regex</key>
      <defaultValue>[a-z]+[a-z0-9]*(\.[a-z0-9]+)*</defaultValue>
    </param>
    <param>
      <key>packageNameRequired</key>
      <defaultValue>false</defaultValue>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.naming.ParameterNameRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Parameter Name]]></name>
    <internalKey><![CDATA[ParameterName]]></internalKey>
    <description><![CDATA[Verifies that the name of each parameter matches a regular expression. This rule applies to method parameters, constructor parameters and closure parameters. By default it checks that parameter names start with a lowercase letter and contains only letters or numbers. The <em>regex</em> property specifies the default regular expression used to validate the parameter name.  The <em>ignoreParameterNames</em> property can specify parameter names that should be ignored, optionally containing wildcard characters ('*' or '?').]]></description>
    <tag>naming</tag>
    <param>
      <key>ignoreParameterNames</key>
    </param>
    <param>
      <key>regex</key>
      <defaultValue>[a-z][a-zA-Z0-9]*</defaultValue>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.naming.PropertyNameRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Property Name]]></name>
    <internalKey><![CDATA[PropertyName]]></internalKey>
    <description><![CDATA[Verifies that the name of each property matches a regular expression. By default it checks that property names other than 'static final' start with a lowercase letter and contains only letters or numbers, and 'static final' property names start with an uppercase letter and contain only uppercase letters, numbers and underscores. The <em>regex</em> property specifies the default regular expression used to validate property names. The <em>finalRegex</em> property specifies the regular expression to validate 'final' property names. The <em>staticRegex</em> property specifies the regular expression to validate 'static' property names. The <em>staticFinalRegex</em> property specifies the regular expression to validate 'static final' property names.  The <em>ignorePropertyNames</em> property can specify property names that should be ignored, optionally containing wildcard characters ('*' or '?').]]></description>
    <tag>naming</tag>
    <param>
      <key>finalRegex</key>
    </param>
    <param>
      <key>staticFinalRegex</key>
      <defaultValue>[A-Z][A-Z0-9_]*</defaultValue>
    </param>
    <param>
      <key>regex</key>
      <defaultValue>[a-z][a-zA-Z0-9]*</defaultValue>
    </param>
    <param>
      <key>ignorePropertyNames</key>
    </param>
    <param>
      <key>staticRegex</key>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.naming.VariableNameRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Variable Name]]></name>
    <internalKey><![CDATA[VariableName]]></internalKey>
    <description><![CDATA[Verifies that the name of each method matches a regular expression. By default it checks that non-'final' variable names start with a lowercase letter and contains only letters or numbers, and 'final' variable names start with an uppercase letter and contain only uppercase letters, numbers and underscores. The <em>regex</em> property specifies the default regular expression used to validate a non-'final' variable name. The <em>finalRegex</em> property specifies the regular expression used to validate 'final' variable names. The <em>ignoreVariableNames</em> property can specify variable names that should be ignored, optionally containing wildcard characters ('*' or '?').]]></description>
    <tag>naming</tag>
    <param>
      <key>finalRegex</key>
      <defaultValue>[A-Z][A-Z0-9_]*</defaultValue>
    </param>
    <param>
      <key>regex</key>
      <defaultValue>[a-z][a-zA-Z0-9]*</defaultValue>
    </param>
    <param>
      <key>ignoreVariableNames</key>
    </param>
  </rule>

  <!-- since 0.16 -->
  <rule>
    <key>org.codenarc.rule.naming.FactoryMethodNameRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Factory Method Name]]></name>
    <internalKey><![CDATA[FactoryMethodName]]></internalKey>
    <description><![CDATA[A factory method is a method that creates objects, and they are typically named either buildFoo(), makeFoo(), or createFoo(). This rule enforces that only one naming convention is used. It defaults to makeFoo(), but that can be changed using the property 'regex'.]]></description>
    <tag>naming</tag>
  </rule>

  <!-- since 0.19 -->
  <rule>
    <key>org.codenarc.rule.naming.ClassNameSameAsFilenameRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Class Name Same As Filename]]></name>
    <internalKey><![CDATA[ClassNameSameAsFilename]]></internalKey>
    <description><![CDATA[Reports files containing only one top level class / enum / interface which is named differently than the file.]]></description>
    <tag>naming</tag>
  </rule>

  <!-- since 0.22 -->
  <rule>
    <key>org.codenarc.rule.naming.PackageNameMatchesFilePathRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Package Name Matches File Path]]></name>
    <internalKey><![CDATA[PackageNameMatchesFilePath]]></internalKey>
    <description><![CDATA[A package source file's path should match the package itself. To find the package-relevant subpath in the file path the <em>groupId</em> <i>needs</i> to be configured. It is expected in every package declaration.]]></description>
    <tag>naming</tag>
  </rule>

  <!-- size rules -->

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.size.AbcMetricRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Abc Metric]]></name>
    <internalKey><![CDATA[AbcMetric]]></internalKey>
    <description><![CDATA[Checks the ABC size metric for methods/classes. A method (or "closure field") with an ABC score greater than the <em>maxMethodAbcScore</em> property causes a violation. Likewise, a class that has an (average method) ABC score greater than the <em>maxClassAverageMethodAbcScore</em> property causes a violation.]]></description>
    <tag>size</tag>
    <param>
      <key>maxMethodAbcScore</key>
      <defaultValue>60</defaultValue>
    </param>
    <param>
      <key>maxClassAverageMethodAbcScore</key>
      <defaultValue>60</defaultValue>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.size.ClassSizeRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Class Size]]></name>
    <internalKey><![CDATA[ClassSize]]></internalKey>
    <description><![CDATA[Checks if the size of a class exceeds the number of lines specified by the <em>maxLines</em> property.]]></description>
    <tag>size</tag>
    <param>
      <key>maxLines</key>
      <defaultValue>1000</defaultValue>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.size.CyclomaticComplexityRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Cyclomatic Complexity]]></name>
    <internalKey><![CDATA[CyclomaticComplexity]]></internalKey>
    <description><![CDATA[Checks the cyclomatic complexity for methods/classes.A method (or "closure field") with a cyclomatic complexity value greater than the <em>maxMethodComplexity</em> property causes a violation. Likewise, a class that has an (average method) cyclomatic complexityvalue greater than the <em>maxClassAverageMethodComplexity</em> property causes a violation.]]></description>
    <tag>size</tag>
    <param>
      <key>maxClassAverageMethodComplexity</key>
      <defaultValue>20</defaultValue>
    </param>
    <param>
      <key>maxMethodComplexity</key>
      <defaultValue>20</defaultValue>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.size.MethodCountRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Method Count]]></name>
    <internalKey><![CDATA[MethodCount]]></internalKey>
    <description><![CDATA[A class with too many methods is probably a good suspect for refactoring, in order to reduce its complexity and find a way to have more fine grained objects.The <em>maxMethods</em> property specifies the threshold.]]></description>
    <tag>size</tag>
    <param>
      <key>maxMethods</key>
      <defaultValue>30</defaultValue>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.size.MethodSizeRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Method Size]]></name>
    <internalKey><![CDATA[MethodSize]]></internalKey>
    <description><![CDATA[Checks if the size of a method exceeds the number of lines specified by the <em>maxLines</em> property.]]></description>
    <tag>size</tag>
    <param>
      <key>maxLines</key>
      <defaultValue>100</defaultValue>
    </param>
  </rule>

  <rule>
    <key>org.codenarc.rule.size.NestedBlockDepthRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Nested Block Depth]]></name>
    <internalKey><![CDATA[NestedBlockDepth]]></internalKey>
    <description><![CDATA[Checks for blocks or closures nested more than <em>maxNestedBlockDepth</em> levels deep.]]></description>
    <tag>size</tag>
  </rule>

  <!-- since 0.17 -->
  <rule>
    <key>org.codenarc.rule.size.CrapMetricRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Crap Metric]]></name>
    <internalKey><![CDATA[CrapMetric]]></internalKey>
    <description><![CDATA[Checks the CRAP (Change Risk Anti-Patterns) score for methods/classes. The CRAP metric score is based on the cyclomatic complexity and test coverage for individual methods. A method with a CRAP value greater than the <em>maxMethodCrapScore</em> property causes a violation. Likewise, a class that has an (average method) CRAP value greater than the <em>maxClassAverageMethodCrapScore</em> property causes a violation.]]></description>
    <tag>size</tag>
    <param>
      <key>maxClassAverageMethodCrapScore</key>
      <defaultValue>30</defaultValue>
    </param>
    <param>
      <key>maxMethodCrapScore</key>
      <defaultValue>30</defaultValue>
    </param>
  </rule>

  <!-- since 0.23 -->
  <rule>
    <key>org.codenarc.rule.size.ParameterCountRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Parameter Count]]></name>
    <internalKey><![CDATA[ParameterCount]]></internalKey>
    <description><![CDATA[Checks if the number of parameters in method/constructor exceeds the number of parameters specified by the maxParameters property.]]></description>
    <tag>size</tag>
  </rule>

  <!-- unnecessary rules -->

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.AddEmptyStringRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Add Empty String]]></name>
    <internalKey><![CDATA[AddEmptyString]]></internalKey>
    <description><![CDATA[Finds empty string literals which are being added. This is an inefficient way to convert any type to a String.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.ConsecutiveLiteralAppendsRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Consecutive Literal Appends]]></name>
    <internalKey><![CDATA[ConsecutiveLiteralAppends]]></internalKey>
    <description><![CDATA[Violations occur when method calls to append(Object) are chained together with literals as parameters. The chained calls can be joined into one invocation.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.ConsecutiveStringConcatenationRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Consecutive String Concatenation]]></name>
    <internalKey><![CDATA[ConsecutiveStringConcatenation]]></internalKey>
    <description><![CDATA[Catches concatenation of two string literals on the same line. These can safely by joined.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryBigDecimalInstantiationRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Big Decimal Instantiation]]></name>
    <internalKey><![CDATA[UnnecessaryBigDecimalInstantiation]]></internalKey>
    <description><![CDATA[It is unnecessary to instantiate BigDecimal objects. Instead just use the decimal literal or the 'G' identifier to force the type, such as 123.45 or 123.45G.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryBigIntegerInstantiationRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Big Integer Instantiation]]></name>
    <internalKey><![CDATA[UnnecessaryBigIntegerInstantiation]]></internalKey>
    <description><![CDATA[It is unnecessary to instantiate BigInteger objects. Instead just use the literal with the 'G' identifier to force the type, such as 8G or 42G.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryBooleanExpressionRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Boolean Expression]]></name>
    <internalKey><![CDATA[UnnecessaryBooleanExpression]]></internalKey>
    <description><![CDATA[Checks for unnecessary boolean expressions, including ANDing (&amp;&amp;) or ORing (||) with <em>true</em>, <em>false</em>, <em>null</em>, or a Map/List/String/Number literal. Also checks for negation (!) of <em>true</em>, <em>false</em>, <em>null</em>, or a Map/List/String/Number literal.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryBooleanInstantiationRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Boolean Instantiation]]></name>
    <internalKey><![CDATA[UnnecessaryBooleanInstantiation]]></internalKey>
    <description><![CDATA[Use <em>Boolean.valueOf()</em> for variable values or <em>Boolean.TRUE</em> and <em>Boolean.FALSE</em> for constant values instead of calling the <em>Boolean()</em> constructor directly or calling <em>Boolean.valueOf(true)</em> or <em>Boolean.valueOf(false)</em>.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryCallForLastElementRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Call For Last Element]]></name>
    <internalKey><![CDATA[UnnecessaryCallForLastElement]]></internalKey>
    <description><![CDATA[This rule checks for excessively verbose methods of accessing the last element of an array or list. For instance, it is possible to access the last element of an array by performing array[array.length - 1], in Groovy it is simpler to either call array.last() or array[-1]. The same is true for lists. This violation is triggered whenever a get, getAt, or array-style access is used with an object size check.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryCallToSubstringRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Call To Substring]]></name>
    <internalKey><![CDATA[UnnecessaryCallToSubstring]]></internalKey>
    <description><![CDATA[Calling String.substring(0) always returns the original string. This code is meaningless.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryCatchBlockRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Catch Block]]></name>
    <internalKey><![CDATA[UnnecessaryCatchBlock]]></internalKey>
    <description><![CDATA[Violations are triggered when a catch block does nothing but throw the original exception. In this scenario there is usually no need for a catch block, just let the exception be thrown from the original code. This condition frequently occurs when catching an exception for debugging purposes but then forgetting to take the catch statement out.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryCollectCallRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Collect Call]]></name>
    <internalKey><![CDATA[UnnecessaryCollectCall]]></internalKey>
    <description><![CDATA[Some method calls to Object.collect(Closure) can be replaced with the spread operator. For instance, list.collect { it.multiply(2) } can be replaced by list*.multiply(2). Warning: if a collection is null, collect will return an empty list, while *. will return null.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryCollectionCallRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Collection Call]]></name>
    <internalKey><![CDATA[UnnecessaryCollectionCall]]></internalKey>
    <description><![CDATA[Useless call to collections. This call doesn't make sense. For any collection c, calling <em>c.containsAll(c)</em> should always be true, and <em>c.retainAll(c)</em> should have no effect.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryConstructorRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Constructor]]></name>
    <internalKey><![CDATA[UnnecessaryConstructor]]></internalKey>
    <description><![CDATA[This rule detects when a constructor is not necessary; i.e., when there's only one constructor, it's public, has an empty body, and takes no arguments.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryDefInMethodDeclarationRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Def In Method Declaration]]></name>
    <internalKey><![CDATA[UnnecessaryDefInMethodDeclaration]]></internalKey>
    <description><![CDATA[If a method has a visibility modifier or a type declaration, then the def keyword is unneeded. For instance 'def private method() {}' is redundant and can be simplified to 'private method() {}'.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryDoubleInstantiationRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Double Instantiation]]></name>
    <internalKey><![CDATA[UnnecessaryDoubleInstantiation]]></internalKey>
    <description><![CDATA[It is unnecessary to instantiate Double objects. Instead just use the double literal or the 'D' identifier to force the type, such as 123.45d or 0.42d.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryFloatInstantiationRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Float Instantiation]]></name>
    <internalKey><![CDATA[UnnecessaryFloatInstantiation]]></internalKey>
    <description><![CDATA[It is unnecessary to instantiate Float objects. Instead just use the float literal with the 'F' identifier to force the type, such as 123.45F or 0.42f.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryGetterRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Getter]]></name>
    <internalKey><![CDATA[UnnecessaryGetter]]></internalKey>
    <description><![CDATA[Checks for explicit calls to getter/accessor methods which can, for the most part, be replaced by property access. A getter is defined as a method call that matches get[A-Z] but not getClass() or get[A-Z][A-Z] such as getURL(). Getters do not take method arguments.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryGStringRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary G String]]></name>
    <internalKey><![CDATA[UnnecessaryGString]]></internalKey>
    <description><![CDATA[String objects should be created with single quotes, and GString objects created with double quotes. Creating normal String objects with double quotes is confusing to readers.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryIfStatementRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary If Statement]]></name>
    <internalKey><![CDATA[UnnecessaryIfStatement]]></internalKey>
    <description><![CDATA[Checks for <em>if</em> statements where the if and else blocks (or subsequent fall-through to a <em>return</em>) are merely returning <em>true</em> and <em>false</em> constants. These cases can be replaced by a simple return statement.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryInstantiationToGetClassRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Instantiation To Get Class]]></name>
    <internalKey><![CDATA[UnnecessaryInstantiationToGetClass]]></internalKey>
    <description><![CDATA[Avoid instantiating an object just to call getClass() on it; use the .class public member instead.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryIntegerInstantiationRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Integer Instantiation]]></name>
    <internalKey><![CDATA[UnnecessaryIntegerInstantiation]]></internalKey>
    <description><![CDATA[It is unnecessary to instantiate Integer objects. Instead just use the literal with the 'I' identifier to force the type, such as 8I or 42i.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryLongInstantiationRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Long Instantiation]]></name>
    <internalKey><![CDATA[UnnecessaryLongInstantiation]]></internalKey>
    <description><![CDATA[It is unnecessary to instantiate Long objects. Instead just use the literal with the 'L' identifier to force the type, such as 8L or 42L.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryModOneRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Mod One]]></name>
    <internalKey><![CDATA[UnnecessaryModOne]]></internalKey>
    <description><![CDATA[Any expression mod 1 (exp % 1) is guaranteed to always return zero. This code is probably an error, and should be either (exp &amp; 1) or (exp % 2).]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryObjectReferencesRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Object References]]></name>
    <internalKey><![CDATA[UnnecessaryObjectReferences]]></internalKey>
    <description><![CDATA[Violations are triggered when an excessive set of consecutive statements all reference the same variable. This can be made more readable by using a with or identity block.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryNullCheckRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Null Check]]></name>
    <internalKey><![CDATA[UnnecessaryNullCheck]]></internalKey>
    <description><![CDATA[Groovy contains the safe dereference operator, which can be used in boolean conditional statements to safely replace explicit "x == null" tests.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryNullCheckBeforeInstanceOfRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Null Check Before Instance Of]]></name>
    <internalKey><![CDATA[UnnecessaryNullCheckBeforeInstanceOf]]></internalKey>
    <description><![CDATA[There is no need to check for null before an instanceof; the instanceof keyword returns false when given a null argument.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryOverridingMethodRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Overriding Method]]></name>
    <internalKey><![CDATA[UnnecessaryOverridingMethod]]></internalKey>
    <description><![CDATA[The overriding method merely calls the same method defined in a superclass]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryPublicModifierRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Public Modifier]]></name>
    <internalKey><![CDATA[UnnecessaryPublicModifier]]></internalKey>
    <description><![CDATA[The 'public' modifier is not required on methods or classes.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryReturnKeywordRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Return Keyword]]></name>
    <internalKey><![CDATA[UnnecessaryReturnKeyword]]></internalKey>
    <description><![CDATA[In Groovy, the return <em>keyword</em> is often optional. If a statement is the last line in a method or closure then you do not need to have the <em>return</em> keyword.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessarySelfAssignmentRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Self Assignment]]></name>
    <internalKey><![CDATA[UnnecessarySelfAssignment]]></internalKey>
    <description><![CDATA[Method contains a pointless self-assignment to a variable or property.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessarySemicolonRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Semicolon]]></name>
    <internalKey><![CDATA[UnnecessarySemicolon]]></internalKey>
    <description><![CDATA[Semicolons as line terminators are not required in Groovy: remove them. Do not use a semicolon as a replacement for empty braces on for and while loops; this is a confusing practice.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryStringInstantiationRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary String Instantiation]]></name>
    <internalKey><![CDATA[UnnecessaryStringInstantiation]]></internalKey>
    <description><![CDATA[Use a String literal (e.g., "...") instead of calling the corresponding String constructor (new String("..")) directly.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryTernaryExpressionRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Ternary Expression]]></name>
    <internalKey><![CDATA[UnnecessaryTernaryExpression]]></internalKey>
    <description><![CDATA[Checks for ternary expressions where the conditional expression always evaluates to a boolean and the true and false expressions are merely returning <em>true</em> and <em>false</em> constants. Also checks for ternary expressions where both expressions are the same constant or variable.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryTransientModifierRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Transient Modifier]]></name>
    <internalKey><![CDATA[UnnecessaryTransientModifier]]></internalKey>
    <description><![CDATA[The field is marked as transient, but the class isn't Serializable, so marking it as transient has no effect.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryFinalOnPrivateMethodRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Final On Private Method]]></name>
    <internalKey><![CDATA[UnnecessaryFinalOnPrivateMethod]]></internalKey>
    <description><![CDATA[A private method is marked final. Private methods cannot be overridden, so marking it final is unnecessary.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryElseStatementRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Else Statement]]></name>
    <internalKey><![CDATA[UnnecessaryElseStatement]]></internalKey>
    <description><![CDATA[When an if statement block ends with a return statement the else is unnecessary. The logic in the else branch can be run without being in a new scope.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryParenthesesForMethodCallWithClosureRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Parentheses For Method Call With Closure]]></name>
    <internalKey><![CDATA[UnnecessaryParenthesesForMethodCallWithClosure]]></internalKey>
    <description><![CDATA[If a method is called and the only parameter to that method is an inline closure then the parentheses of the method call can be omitted.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryPackageReferenceRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Package Reference]]></name>
    <internalKey><![CDATA[UnnecessaryPackageReference]]></internalKey>
    <description><![CDATA[Checks for explicit package reference for classes that Groovy imports by default, such as <em>java.lang.String</em>, <em>java.util.Map</em> and <em>groovy.lang.Closure</em>.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryDefInVariableDeclarationRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Def In Variable Declaration]]></name>
    <internalKey><![CDATA[UnnecessaryDefInVariableDeclaration]]></internalKey>
    <description><![CDATA[If a variable has a visibility modifier or a type declaration, then the def keyword is unneeded. For instance 'def private n = 2' is redundant and can be simplified to 'private n = 2'.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryDotClassRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Dot Class]]></name>
    <internalKey><![CDATA[UnnecessaryDotClass]]></internalKey>
    <description><![CDATA[To make a reference to a class, it is unnecessary to specify the '.class' identifier. For instance String.class can be shortened to String.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryInstanceOfCheckRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Instance Of Check]]></name>
    <internalKey><![CDATA[UnnecessaryInstanceOfCheck]]></internalKey>
    <description><![CDATA[This rule finds instanceof checks that cannot possibly evaluate to true. For instance, checking that (!variable instanceof String) will never be true because the result of a not expression is always a boolean.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessarySubstringRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Substring]]></name>
    <internalKey><![CDATA[UnnecessarySubstring]]></internalKey>
    <description><![CDATA[This rule finds usages of String.substring(int) and String.substring(int, int) that can be replaced by use of the subscript operator. For instance, var.substring(5) can be replaced with var[5..-1].]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.16 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryDefInFieldDeclarationRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Def In Field Declaration]]></name>
    <internalKey><![CDATA[UnnecessaryDefInFieldDeclaration]]></internalKey>
    <description><![CDATA[If a field has a visibility modifier or a type declaration, then the def keyword is unneeded. For instance, 'static def constraints = {}' is redundant and can be simplified to 'static constraints = {}.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.21 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryCastRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Unnecessary Cast]]></name>
    <internalKey><![CDATA[UnnecessaryCast]]></internalKey>
    <description><![CDATA[Checks for unnecessary cast operations]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.21 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessaryToStringRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Unnecessary To String]]></name>
    <internalKey><![CDATA[UnnecessaryToString]]></internalKey>
    <description><![CDATA[Checks for unnecessary calls to <em>toString()</em>.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- since 0.22 -->
  <rule>
    <key>org.codenarc.rule.unnecessary.UnnecessarySafeNavigationOperatorRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Safe Navigation Operator]]></name>
    <internalKey><![CDATA[UnnecessarySafeNavigationOperator]]></internalKey>
    <description><![CDATA[Check for the <em>safe navigation operator</em> (?.) applied to constants and literals, which can never be null.]]></description>
    <tag>unnecessary</tag>
  </rule>

  <!-- unused rules -->

  <rule>
    <key>org.codenarc.rule.unused.UnusedArrayRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Unused Array]]></name>
    <internalKey><![CDATA[UnusedArray]]></internalKey>
    <description><![CDATA[Checks for array allocations that are not assigned or used, unless it is the last statement within a block.]]></description>
    <tag>unused</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.unused.UnusedObjectRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Unused Object]]></name>
    <internalKey><![CDATA[UnusedObject]]></internalKey>
    <description><![CDATA[Checks for object allocations that are not assigned or used, unless it is the last statement within a block]]></description>
    <tag>unused</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.unused.UnusedPrivateFieldRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Unused Private Field]]></name>
    <internalKey><![CDATA[UnusedPrivateField]]></internalKey>
    <description><![CDATA[Checks for private fields that are not referenced within the same class.]]></description>
    <tag>unused</tag>
  </rule>

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.unused.UnusedPrivateMethodParameterRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Unused Private Method Parameter]]></name>
    <internalKey><![CDATA[UnusedPrivateMethodParameter]]></internalKey>
    <description><![CDATA[Checks for parameters to private methods that are not referenced within the method body.]]></description>
    <tag>unused</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.unused.UnusedPrivateMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Unused Private Method]]></name>
    <internalKey><![CDATA[UnusedPrivateMethod]]></internalKey>
    <description><![CDATA[Checks for private methods that are not referenced within the same class.]]></description>
    <tag>unused</tag>
  </rule>

  <rule>
    <key>org.codenarc.rule.unused.UnusedVariableRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Unused Variable]]></name>
    <internalKey><![CDATA[UnusedVariable]]></internalKey>
    <description><![CDATA[Checks for variables that are never referenced. The <em>ignoreVariableNames</em> property specifies one or more variable names that should be ignored, optionally containing wildcard characters ('*' or '?').]]></description>
    <tag>unused</tag>
    <param>
      <key>ignoreVariableNames</key>
    </param>
  </rule>

  <!-- since 0.16 -->
  <rule>
    <key>org.codenarc.rule.unused.UnusedMethodParameterRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Unused Method Parameter]]></name>
    <internalKey><![CDATA[UnusedMethodParameter]]></internalKey>
    <description><![CDATA[This rule finds instances of method parameters not being used. It does not analyze private methods (that is done by the UnusedPrivateMethodParameter rule) or methods marked @Override. ]]></description>
    <tag>unused</tag>
  </rule>

  <!-- jdbc rules -->

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.jdbc.DirectConnectionManagementRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Direct Connection Management]]></name>
    <internalKey><![CDATA[DirectConnectionManagement]]></internalKey>
    <description><![CDATA[The J2EE standard requires that applications use the container's resource management facilities to obtain connections to resources. Every major web application container provides pooled database connection management as part of its resource management framework. Duplicating this functionality in an application is difficult and error prone, which is part of the reason it is forbidden under the J2EE standard.]]></description>
    <tag>jdbc</tag>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.jdbc.JdbcConnectionReferenceRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Jdbc Connection Reference]]></name>
    <internalKey><![CDATA[JdbcConnectionReference]]></internalKey>
    <description><![CDATA[Check for direct use of <em>java.sql.Connection</em>, which is discouraged and almost never necessary in application code.]]></description>
    <tag>jdbc</tag>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.jdbc.JdbcResultSetReferenceRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Jdbc Result Set Reference]]></name>
    <internalKey><![CDATA[JdbcResultSetReference]]></internalKey>
    <description><![CDATA[Check for direct use of <em>java.sql.ResultSet</em>, which is not necessary if using the Groovy <em>Sql</em> facility or an ORM framework such as Hibernate.]]></description>
    <tag>jdbc</tag>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.jdbc.JdbcStatementReferenceRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Jdbc Statement Reference]]></name>
    <internalKey><![CDATA[JdbcStatementReference]]></internalKey>
    <description><![CDATA[Check for direct use of <em>java.sql.Statement</em>, <em>java.sql.PreparedStatement</em>, or <em>java.sql.CallableStatement</em>, which is not necessary if using the Groovy <em>Sql</em> facility or an ORM framework such as Hibernate.]]></description>
    <tag>jdbc</tag>
  </rule>

  <!-- security rules -->

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.security.NonFinalSubclassOfSensitiveInterfaceRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Non Final Subclass Of Sensitive Interface]]></name>
    <internalKey><![CDATA[NonFinalSubclassOfSensitiveInterface]]></internalKey>
    <description><![CDATA[The permissions classes such as java.security.Permission and java.security.BasicPermission are designed to be extended. Classes that derive from these permissions classes, however, must prohibit extension. This prohibition ensures that malicious subclasses cannot change the properties of the derived class. Classes that implement sensitive interfaces such as java.security.PrivilegedAction and java.security.PrivilegedActionException must also be declared final for analogous reasons.]]></description>
    <tag>security</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.security.InsecureRandomRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Insecure Random]]></name>
    <internalKey><![CDATA[InsecureRandom]]></internalKey>
    <description><![CDATA[Reports usages of java.util.Random, which can produce very predictable results. If two instances of Random are created with the same seed and sequence of method calls, they will generate the exact same results. Use java.security.SecureRandom instead, which provides a cryptographically strong random number generator. SecureRandom uses PRNG, which means they are using a deterministic algorithm to produce a pseudo-random number from a true random seed. SecureRandom produces non-deterministic output.]]></description>
    <tag>security</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.security.FileCreateTempFileRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[File Create Temp File]]></name>
    <internalKey><![CDATA[FileCreateTempFile]]></internalKey>
    <description><![CDATA[The File.createTempFile() method is insecure, and has been deprecated by the ESAPI secure coding library. It has been replaced by the ESAPI Randomizer.getRandomFilename(String) method.]]></description>
    <tag>security</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.security.SystemExitRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[System Exit]]></name>
    <internalKey><![CDATA[SystemExit]]></internalKey>
    <description><![CDATA[Web applications should never call System.exit(). A call to System.exit() is probably part of leftover debug code or code imported from a non-J2EE application.]]></description>
    <tag>security</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.security.ObjectFinalizeRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Object Finalize]]></name>
    <internalKey><![CDATA[ObjectFinalize]]></internalKey>
    <description><![CDATA[The finalize() method should only be called by the JVM after the object has been garbage collected.]]></description>
    <tag>security</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.security.JavaIoPackageAccessRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Java Io Package Access]]></name>
    <internalKey><![CDATA[JavaIoPackageAccess]]></internalKey>
    <description><![CDATA[This rule reports violations of the Enterprise JavaBeans specification by using the java.io package to access files or the file system.]]></description>
    <tag>security</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.security.UnsafeArrayDeclarationRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Unsafe Array Declaration]]></name>
    <internalKey><![CDATA[UnsafeArrayDeclaration]]></internalKey>
    <description><![CDATA[Triggers a violation when an array is declared public, final, and static. Secure coding principles state that, in most cases, an array declared public, final and static is a bug because arrays are mutable objects.]]></description>
    <tag>security</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.security.PublicFinalizeMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Public Finalize Method]]></name>
    <internalKey><![CDATA[PublicFinalizeMethod]]></internalKey>
    <description><![CDATA[Creates a violation when the program violates secure coding principles by declaring a finalize() method public.]]></description>
    <tag>security</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.security.NonFinalPublicFieldRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Non Final Public Field]]></name>
    <internalKey><![CDATA[NonFinalPublicField]]></internalKey>
    <description><![CDATA[Finds code that violates secure coding principles for mobile code by declaring a member variable public but not final.]]></description>
    <tag>security</tag>
  </rule>

  <!-- since 0.19 -->
  <rule>
    <key>org.codenarc.rule.security.UnsafeImplementationAsMapRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Unsafe Implementation As Map]]></name>
    <internalKey><![CDATA[UnsafeImplementationAsMap]]></internalKey>
    <description><![CDATA[Reports incomplete interface implementations created by map-to-interface coercions. Example: [hasNext: { ... }] as Iterator (Not all Iterator methods are implemented. An UnsupportedOperationException will be thrown upon call to e.g. next().) By default, this rule does not apply to test files.]]></description>
    <tag>security</tag>
  </rule>

  <!-- formatting rules -->

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.formatting.BracesForClassRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Braces For Class]]></name>
    <internalKey><![CDATA[BracesForClass]]></internalKey>
    <description><![CDATA[Checks the location of the opening brace ({) for classes. By default, requires them on the same line, but the sameLine property can be set to false to override this.]]></description>
    <tag>formatting</tag>
    <param>
      <key>sameLine</key>
      <defaultValue>true</defaultValue>
    </param>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.formatting.LineLengthRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Line Length]]></name>
    <internalKey><![CDATA[LineLength]]></internalKey>
    <description><![CDATA[Checks the maximum length for each line of source code. It checks for number of characters, so lines that include tabs may appear longer than the allowed number when viewing the file. The maximum line length can be configured by setting the length property, which defaults to 120.]]></description>
    <tag>formatting</tag>
    <param>
      <key>length</key>
      <defaultValue>120</defaultValue>
    </param>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.formatting.BracesForForLoopRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Braces For For Loop]]></name>
    <internalKey><![CDATA[BracesForForLoop]]></internalKey>
    <description><![CDATA[Checks the location of the opening brace ({) for for loops. By default, requires them on the same line, but the sameLine property can be set to false to override this.]]></description>
    <tag>formatting</tag>
    <param>
      <key>sameLine</key>
      <defaultValue>true</defaultValue>
    </param>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.formatting.BracesForIfElseRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Braces For If Else]]></name>
    <internalKey><![CDATA[BracesForIfElse]]></internalKey>
    <description><![CDATA[Checks the location of the opening brace ({) for if statements. By default, requires them on the same line, but the sameLine property can be set to false to override this.]]></description>
    <tag>formatting</tag>
    <param>
      <key>sameLine</key>
      <defaultValue>true</defaultValue>
    </param>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.formatting.BracesForMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Braces For Method]]></name>
    <internalKey><![CDATA[BracesForMethod]]></internalKey>
    <description><![CDATA[Checks the location of the opening brace ({) for constructors and methods. By default, requires them on the same line, but the sameLine property can be set to false to override this.]]></description>
    <tag>formatting</tag>
    <param>
      <key>sameLine</key>
      <defaultValue>true</defaultValue>
    </param>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.formatting.BracesForTryCatchFinallyRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Braces For Try Catch Finally]]></name>
    <internalKey><![CDATA[BracesForTryCatchFinally]]></internalKey>
    <description><![CDATA[Checks the location of the opening brace ({) for try statements. By default, requires them on the line, but the sameLine property can be set to false to override this.]]></description>
    <tag>formatting</tag>
    <param>
      <key>sameLine</key>
      <defaultValue>true</defaultValue>
    </param>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.formatting.ClassJavadocRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Class Javadoc]]></name>
    <internalKey><![CDATA[ClassJavadoc]]></internalKey>
    <description><![CDATA[Makes sure each class and interface definition is preceded by javadoc. Enum definitions are not checked, due to strange behavior in the Groovy AST.]]></description>
    <tag>formatting</tag>
  </rule>

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.formatting.SpaceAfterCommaRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Space After Comma]]></name>
    <internalKey><![CDATA[SpaceAfterComma]]></internalKey>
    <description><![CDATA[Checks that there is at least one space or whitespace following each comma. That includes checks for method and closure declaration parameter lists, method call parameter lists, Map literals and List literals.]]></description>
    <tag>formatting</tag>
  </rule>

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.formatting.SpaceAfterSemicolonRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Space After Semicolon]]></name>
    <internalKey><![CDATA[SpaceAfterSemicolon]]></internalKey>
    <description><![CDATA[Checks that there is at least one space or whitespace following each semicolon separating multiple statements on a single line or the clauses within a classic for loop.]]></description>
    <tag>formatting</tag>
  </rule>

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.formatting.SpaceAroundOperatorRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Space Around Operator]]></name>
    <internalKey><![CDATA[SpaceAroundOperator]]></internalKey>
    <description><![CDATA[Check that there is at least one space (blank) or whitespace around each binary operator.]]></description>
    <tag>formatting</tag>
  </rule>

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.formatting.SpaceBeforeOpeningBraceRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Space Before Opening Brace]]></name>
    <internalKey><![CDATA[SpaceBeforeOpeningBrace]]></internalKey>
    <description><![CDATA[Check that there is at least one space (blank) or whitespace before each opening brace ("{") for method/class/interface declarations, closure expressions and block statements.]]></description>
    <tag>formatting</tag>
  </rule>

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.formatting.SpaceAfterOpeningBraceRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Space After Opening Brace]]></name>
    <internalKey><![CDATA[SpaceAfterOpeningBrace]]></internalKey>
    <description><![CDATA[Check that there is at least one space (blank) or whitespace after each opening brace ("{") for method/class/interface declarations, closure expressions and block statements.]]></description>
    <tag>formatting</tag>
  </rule>

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.formatting.SpaceAfterClosingBraceRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Space After Closing Brace]]></name>
    <internalKey><![CDATA[SpaceAfterClosingBrace]]></internalKey>
    <description><![CDATA[Check that there is at least one space (blank) or whitespace after each closing brace ("}") for method/class/interface declarations, closure expressions and block statements.]]></description>
    <tag>formatting</tag>
  </rule>

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.formatting.SpaceBeforeClosingBraceRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Space Before Closing Brace]]></name>
    <internalKey><![CDATA[SpaceBeforeClosingBrace]]></internalKey>
    <description><![CDATA[Check that there is at least one space (blank) or whitespace before each closing brace ("}") for method/class/interface declarations, closure expressions and block statements.]]></description>
    <tag>formatting</tag>
  </rule>

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.formatting.SpaceAfterIfRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Space After If]]></name>
    <internalKey><![CDATA[SpaceAfterIf]]></internalKey>
    <description><![CDATA[Check that there is exactly one space (blank) after the <em>if</em> keyword and before the opening parenthesis.]]></description>
    <tag>formatting</tag>
  </rule>

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.formatting.SpaceAfterWhileRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Space After While]]></name>
    <internalKey><![CDATA[SpaceAfterWhile]]></internalKey>
    <description><![CDATA[Check that there is exactly one space (blank) after the <em>while</em> keyword and before the opening parenthesis.]]></description>
    <tag>formatting</tag>
  </rule>

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.formatting.SpaceAfterForRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Space After For]]></name>
    <internalKey><![CDATA[SpaceAfterFor]]></internalKey>
    <description><![CDATA[Check that there is exactly one space (blank) after the <em>for</em> keyword and before the opening parenthesis.]]></description>
    <tag>formatting</tag>
  </rule>

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.formatting.SpaceAfterSwitchRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Space After Switch]]></name>
    <internalKey><![CDATA[SpaceAfterSwitch]]></internalKey>
    <description><![CDATA[Check that there is exactly one space (blank) after the <em>switch</em> keyword and before the opening parenthesis.]]></description>
    <tag>formatting</tag>
  </rule>

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.formatting.SpaceAfterCatchRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Space After Catch]]></name>
    <internalKey><![CDATA[SpaceAfterCatch]]></internalKey>
    <description><![CDATA[Check that there is exactly one space (blank) after the <em>catch</em> keyword and before the opening parenthesis.]]></description>
    <tag>formatting</tag>
  </rule>

  <!-- since 0.19 -->
  <rule>
    <key>org.codenarc.rule.formatting.SpaceAroundClosureArrowRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Space Around Closure Arrow]]></name>
    <internalKey><![CDATA[SpaceAroundClosureArrow]]></internalKey>
    <description><![CDATA[Checks that there is whitespace around the closure arrow (->) symbol]]></description>
    <tag>formatting</tag>
  </rule>

  <!-- since 0.20 -->
  <rule>
    <key>org.codenarc.rule.formatting.SpaceAroundMapEntryColonRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Space Around Map Entry Colon]]></name>
    <internalKey><![CDATA[SpaceAroundMapEntryColon]]></internalKey>
    <description><![CDATA[Check for configured formatting of whitespace around colons for literal Map entries. The <em>characterBeforeColonRegex</em> and <em>characterAfterColonRegex</em> properties specify a regular expression that must match the character before/after the colon.]]></description>
    <tag>formatting</tag>
  </rule>

  <!-- since 0.20 -->
  <rule>
    <key>org.codenarc.rule.formatting.ClosureStatementOnOpeningLineOfMultipleLineClosureRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Closure Statement On Opening Line Of Multiple Line Closure]]></name>
    <internalKey><![CDATA[ClosureStatementOnOpeningLineOfMultipleLineClosure]]></internalKey>
    <description><![CDATA[Checks for closure logic on first line (after ->) for a multi-line closure.]]></description>
    <tag>formatting</tag>
  </rule>

  <!-- since 0.21 -->
  <rule>
    <key>org.codenarc.rule.formatting.ConsecutiveBlankLinesRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Consecutive Blank Lines]]></name>
    <internalKey><![CDATA[ConsecutiveBlankLines]]></internalKey>
    <description><![CDATA[Makes sure there are no consecutive lines that are either blank or whitespace only.]]></description>
    <tag>formatting</tag>
  </rule>

  <!-- since 0.21 -->
  <rule>
    <key>org.codenarc.rule.formatting.BlankLineBeforePackageRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Blank Line Before Package]]></name>
    <internalKey><![CDATA[BlankLineBeforePackage]]></internalKey>
    <description><![CDATA[Makes sure there are no blank lines before the package declaration of a source code file.]]></description>
    <tag>formatting</tag>
  </rule>

  <!-- since 0.21 -->
  <rule>
    <key>org.codenarc.rule.formatting.FileEndsWithoutNewlineRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[File Ends Without Newline]]></name>
    <internalKey><![CDATA[FileEndsWithoutNewline]]></internalKey>
    <description><![CDATA[Makes sure the source code file ends with a newline character.]]></description>
    <tag>formatting</tag>
  </rule>

  <!-- since 0.21 -->
  <rule>
    <key>org.codenarc.rule.formatting.MissingBlankLineAfterImportsRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Missing Blank Line After Imports]]></name>
    <internalKey><![CDATA[MissingBlankLineAfterImports]]></internalKey>
    <description><![CDATA[Makes sure there is a blank line after the imports of a source code file.]]></description>
    <tag>formatting</tag>
  </rule>

  <!-- since 0.21 -->
  <rule>
    <key>org.codenarc.rule.formatting.MissingBlankLineAfterPackageRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Missing Blank Line After Package]]></name>
    <internalKey><![CDATA[MissingBlankLineAfterPackage]]></internalKey>
    <description><![CDATA[Makes sure there is a blank line after the package statement of a source code file.]]></description>
    <tag>formatting</tag>
  </rule>

  <!-- since 0.21 -->
  <rule>
    <key>org.codenarc.rule.formatting.TrailingWhitespaceRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Trailing Whitespace]]></name>
    <internalKey><![CDATA[TrailingWhitespace]]></internalKey>
    <description><![CDATA[Checks that no lines of source code end with whitespace characters.]]></description>
    <tag>formatting</tag>
  </rule>

  <!-- convention rules -->

  <!-- since 0.12 -->
  <rule>
    <key>org.codenarc.rule.convention.ConfusingTernaryRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Confusing Ternary]]></name>
    <internalKey><![CDATA[ConfusingTernary]]></internalKey>
    <description><![CDATA[In a ternary expression avoid negation in the test. For example, rephrase: "(x != y) ? diff : same" as: "(x == y) ? same : diff". Consistent use of this rule makes the code easier to read. Also, this resolves trivial ordering problems, such as "does the error case go first?" or "does the common case go first?".]]></description>
    <tag>convention</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.convention.InvertedIfElseRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Inverted If Else]]></name>
    <internalKey><![CDATA[InvertedIfElse]]></internalKey>
    <description><![CDATA[An inverted if-else statement is one in which there is a single <em>if</em> statement with a single <em>else</em> branch and the boolean test of the if is negated. For instance <em>if (!x) false else true</em>. It is usually clearer to write this as <em>if (x) true else false</em>.]]></description>
    <tag>convention</tag>
  </rule>

  <!-- since 0.16 -->
  <rule>
    <key>org.codenarc.rule.convention.CouldBeElvisRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Could Be Elvis]]></name>
    <internalKey><![CDATA[CouldBeElvis]]></internalKey>
    <description><![CDATA[Catch an if block that could be written as an elvis expression.]]></description>
    <tag>convention</tag>
  </rule>

  <!-- since 0.16 -->
  <rule>
    <key>org.codenarc.rule.convention.LongLiteralWithLowerCaseLRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Long Literal With Lower Case L]]></name>
    <internalKey><![CDATA[LongLiteralWithLowerCaseL]]></internalKey>
    <description><![CDATA[In Java and Groovy, you can specify long literals with the L or l character, for instance 55L or 24l. It is best practice to always use an uppercase L and never a lowercase l. This is because 11l rendered in some fonts may look like 111 instead of 11L.]]></description>
    <tag>convention</tag>
  </rule>

  <!-- since 0.17 -->
  <rule>
    <key>org.codenarc.rule.convention.ParameterReassignmentRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Parameter Reassignment]]></name>
    <internalKey><![CDATA[ParameterReassignment]]></internalKey>
    <description><![CDATA[Checks for a method or closure parameter being reassigned to a new value within the body of the method/closure, which is a confusing and questionable practice. Use a temporary variable instead.]]></description>
    <tag>convention</tag>
  </rule>

  <!-- since 0.17 -->
  <rule>
    <key>org.codenarc.rule.convention.TernaryCouldBeElvisRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Ternary Could Be Elvis]]></name>
    <internalKey><![CDATA[TernaryCouldBeElvis]]></internalKey>
    <description><![CDATA[Checks for ternary expressions where the boolean and true expressions are the same. These can be simplified to an Elvis expression.]]></description>
    <tag>convention</tag>
  </rule>

  <!-- since 0.17 -->
  <rule>
    <key>org.codenarc.rule.convention.VectorIsObsoleteRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Vector Is Obsolete]]></name>
    <internalKey><![CDATA[VectorIsObsolete]]></internalKey>
    <description><![CDATA[The <em>java.util.Vector</em> class is effectively obsolete. Use the <em>Java Collections Framework</em> classes instead, including <em>ArrayList</em> or <em>Collections.synchronizedList()</em>. See the JDK javadoc.]]></description>
    <tag>convention</tag>
  </rule>

  <!-- since 0.17 -->
  <rule>
    <key>org.codenarc.rule.convention.HashtableIsObsoleteRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Hashtable Is Obsolete]]></name>
    <internalKey><![CDATA[HashtableIsObsolete]]></internalKey>
    <description><![CDATA[The <em>java.util.Hashtable</em> class is effectively obsolete. Use the <em>Java Collections Framework</em> classes instead, including <em>HashMap</em> or <em>ConcurrentHashMap</em>. See the JDK javadoc.]]></description>
    <tag>convention</tag>
  </rule>

  <!-- since 0.18 -->
  <rule>
    <key>org.codenarc.rule.convention.IfStatementCouldBeTernaryRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[If Statement Could Be Ternary]]></name>
    <internalKey><![CDATA[IfStatementCouldBeTernary]]></internalKey>
    <description><![CDATA[Checks for <em>if</em> statements where both the <em>if</em> and <em>else</em> blocks contain only a single <em>return</em> statement with a constant or literal value]]></description>
    <tag>convention</tag>
  </rule>

  <!-- since 0.22 -->
  <rule>
    <key>org.codenarc.rule.convention.NoDefRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[No Def]]></name>
    <internalKey><![CDATA[NoDef]]></internalKey>
    <description><![CDATA[<em>def</em> should not be used. You should replace it with concrete type.]]></description>
    <tag>convention</tag>
  </rule>

  <!-- groovyism rules -->

  <!-- since 0.16 -->
  <rule>
    <key>org.codenarc.rule.groovyism.AssignCollectionSortRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Assign Collection Sort]]></name>
    <internalKey><![CDATA[AssignCollectionSort]]></internalKey>
    <description><![CDATA[The Collections.sort() method mutates the list and returns the list as a value. If you are assigning the result of sort() to a variable, then you probably don't realize that you're also modifying the original list as well. This is frequently the cause of subtle bugs.]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitArrayListInstantiationRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Array List Instantiation]]></name>
    <internalKey><![CDATA[ExplicitArrayListInstantiation]]></internalKey>
    <description><![CDATA[This rule checks for the explicit instantiation of an <em>ArrayList</em> using the no-arg constructor. In Groovy, it is best to write <em>new ArrayList()</em> as <em>[]</em>, which creates the same object.]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitCallToAndMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Call To And Method]]></name>
    <internalKey><![CDATA[ExplicitCallToAndMethod]]></internalKey>
    <description><![CDATA[This rule detects when the <em>and(Object)</em> method is called directly in code instead of using the &amp; operator. A groovier way to express this: <em>a.and(b)</em> is this: <em>a &amp; b</em>]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitCallToCompareToMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Call To Compare To Method]]></name>
    <internalKey><![CDATA[ExplicitCallToCompareToMethod]]></internalKey>
    <description><![CDATA[This rule detects when the <em>compareTo(Object)</em> method is called directly in code instead of using the &lt;=&gt;, &gt;, &gt;=, &lt;, and &lt;= operators. A groovier way to express this: <em>a.compareTo(b)</em> is this: <em>a &lt;=&gt; b</em>, or using the other operators.]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitCallToDivMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Call To Div Method]]></name>
    <internalKey><![CDATA[ExplicitCallToDivMethod]]></internalKey>
    <description><![CDATA[This rule detects when the <em>div(Object)</em> method is called directly in code instead of using the / operator. A groovier way to express this: <em>a.div(b)</em> is this: <em>a / b</em>]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitCallToEqualsMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Call To Equals Method]]></name>
    <internalKey><![CDATA[ExplicitCallToEqualsMethod]]></internalKey>
    <description><![CDATA[This rule detects when the <em>equals(Object)</em> method is called directly in code instead of using the == or != operator. A groovier way to express this: <em>a.equals(b)</em> is this: <em>a == b</em> and a groovier way to express : <em>!a.equals(b)</em> is : <em>a != b</em>]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitCallToGetAtMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Call To Get At Method]]></name>
    <internalKey><![CDATA[ExplicitCallToGetAtMethod]]></internalKey>
    <description><![CDATA[This rule detects when the <em>getAt(Object)</em> method is called directly in code instead of using the [] index operator. A groovier way to express this: <em>a.getAt(b)</em> is this: <em>a[b]</em>]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitCallToLeftShiftMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Call To Left Shift Method]]></name>
    <internalKey><![CDATA[ExplicitCallToLeftShiftMethod]]></internalKey>
    <description><![CDATA[This rule detects when the <em>leftShift(Object)</em> method is called directly in code instead of using the &lt;&lt; operator. A groovier way to express this: <em>a.leftShift(b)</em> is this: <em>a &lt;&lt; b</em>]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitCallToMinusMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Call To Minus Method]]></name>
    <internalKey><![CDATA[ExplicitCallToMinusMethod]]></internalKey>
    <description><![CDATA[This rule detects when the <em>minus(Object)</em> method is called directly in code instead of using the - operator. A groovier way to express this: <em>a.minus(b)</em> is this: <em>a - b</em>]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitCallToMultiplyMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Call To Multiply Method]]></name>
    <internalKey><![CDATA[ExplicitCallToMultiplyMethod]]></internalKey>
    <description><![CDATA[This rule detects when the <em>minus(Object)</em> method is called directly in code instead of using the * operator. A groovier way to express this: <em>a.multiply(b)</em> is this: <em>a * b</em>]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitCallToModMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Call To Mod Method]]></name>
    <internalKey><![CDATA[ExplicitCallToModMethod]]></internalKey>
    <description><![CDATA[This rule detects when the <em>mod(Object)</em> method is called directly in code instead of using the % operator. A groovier way to express this: <em>a.mod(b)</em> is this: <em>a % b</em>]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitCallToOrMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Call To Or Method]]></name>
    <internalKey><![CDATA[ExplicitCallToOrMethod]]></internalKey>
    <description><![CDATA[This rule detects when the <em>or(Object)</em> method is called directly in code instead of using the | operator. A groovier way to express this: <em>a.or(b)</em> is this: <em>a | b</em>]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitCallToPlusMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Call To Plus Method]]></name>
    <internalKey><![CDATA[ExplicitCallToPlusMethod]]></internalKey>
    <description><![CDATA[This rule detects when the <em>plus(Object)</em> method is called directly in code instead of using the + operator. A groovier way to express this: <em>a.plus(b)</em> is this: <em>a + b</em>]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitCallToPowerMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Call To Power Method]]></name>
    <internalKey><![CDATA[ExplicitCallToPowerMethod]]></internalKey>
    <description><![CDATA[This rule detects when the <em>power(Object)</em> method is called directly in code instead of using the ** operator. A groovier way to express this: <em>a.power(b)</em> is this: <em>a ** b</em>]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitCallToRightShiftMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Call To Right Shift Method]]></name>
    <internalKey><![CDATA[ExplicitCallToRightShiftMethod]]></internalKey>
    <description><![CDATA[This rule detects when the <em>rightShift(Object)</em> method is called directly in code instead of using the >> operator. A groovier way to express this: <em>a.rightShift(b)</em> is this: <em>a >> b</em>]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitCallToXorMethodRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Call To Xor Method]]></name>
    <internalKey><![CDATA[ExplicitCallToXorMethod]]></internalKey>
    <description><![CDATA[This rule detects when the <em>xor(Object)</em> method is called directly in code instead of using the ^ operator. A groovier way to express this: <em>a.xor(b)</em> is this: <em>a ^ b</em>]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitHashMapInstantiationRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Hash Map Instantiation]]></name>
    <internalKey><![CDATA[ExplicitHashMapInstantiation]]></internalKey>
    <description><![CDATA[This rule checks for the explicit instantiation of a <em>HashMap</em> using the no-arg constructor. In Groovy, it is best to write <em>new HashMap()</em> as <em>[:]</em>, which creates the same object.]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitHashSetInstantiationRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Hash Set Instantiation]]></name>
    <internalKey><![CDATA[ExplicitHashSetInstantiation]]></internalKey>
    <description><![CDATA[This rule checks for the explicit instantiation of a <em>HashSet</em> using the no-arg constructor. In Groovy, it is best to write <em>new HashSet()</em> as <em>[] as Set</em>, which creates the same object.]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitLinkedListInstantiationRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Linked List Instantiation]]></name>
    <internalKey><![CDATA[ExplicitLinkedListInstantiation]]></internalKey>
    <description><![CDATA[This rule checks for the explicit instantiation of a <em>LinkedList</em> using the no-arg constructor. In Groovy, it is best to write <em>new LinkedList()</em> as <em>[] as Queue</em>, which creates the same object.]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitStackInstantiationRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Stack Instantiation]]></name>
    <internalKey><![CDATA[ExplicitStackInstantiation]]></internalKey>
    <description><![CDATA[This rule checks for the explicit instantiation of a <em>Stack</em> using the no-arg constructor. In Groovy, it is best to write <em>new Stack()</em> as <em>[] as Stack</em>, which creates the same object.]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitTreeSetInstantiationRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Tree Set Instantiation]]></name>
    <internalKey><![CDATA[ExplicitTreeSetInstantiation]]></internalKey>
    <description><![CDATA[This rule checks for the explicit instantiation of a <em>TreeSet</em> using the no-arg constructor. In Groovy, it is best to write <em>new TreeSet()</em> as <em>[] as SortedSet</em>, which creates the same object.]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.13 -->
  <rule>
    <key>org.codenarc.rule.groovyism.GroovyLangImmutableRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Groovy Lang Immutable]]></name>
    <internalKey><![CDATA[GroovyLangImmutable]]></internalKey>
    <description><![CDATA[The groovy.lang.Immutable annotation has been deprecated and replaced by groovy.transform.Immutable. Do not use the Immutable in groovy.lang.]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.11 -->
  <rule>
    <key>org.codenarc.rule.groovyism.GStringAsMapKeyRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[G String As Map Key]]></name>
    <internalKey><![CDATA[GStringAsMapKey]]></internalKey>
    <description><![CDATA[A GString should not be used as a map key since its hashcode is not guaranteed to be stable. Consider calling <em>key.toString()</em>.]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ExplicitLinkedHashMapInstantiationRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Explicit Linked Hash Map Instantiation]]></name>
    <internalKey><![CDATA[ExplicitLinkedHashMapInstantiation]]></internalKey>
    <description><![CDATA[This rule checks for the explicit instantiation of a <em>LinkedHashMap</em> using the no-arg constructor. In Groovy, it is best to write <em>new LinkedHashMap()</em> as <em>[:]</em>, which creates the same object.]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.14 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ClosureAsLastMethodParameterRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Closure As Last Method Parameter]]></name>
    <internalKey><![CDATA[ClosureAsLastMethodParameter]]></internalKey>
    <description><![CDATA[If a method is called and the last parameter is an inline closure then it can be declared outside of the method call brackets.]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.15 -->
  <rule>
    <key>org.codenarc.rule.groovyism.AssignCollectionUniqueRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Assign Collection Unique]]></name>
    <internalKey><![CDATA[AssignCollectionUnique]]></internalKey>
    <description><![CDATA[The Collections.unique() method mutates the list and returns the list as a value. If you are assigning the result of unique() to a variable, then you probably don't realize that you're also modifying the original list as well. This is frequently the cause of subtle bugs.]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.16 -->
  <rule>
    <key>org.codenarc.rule.groovyism.ConfusingMultipleReturnsRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Confusing Multiple Returns]]></name>
    <internalKey><![CDATA[ConfusingMultipleReturns]]></internalKey>
    <description><![CDATA[Multiple return values can be used to set several variables at once. To use multiple return values, the left hand side of the assignment must be enclosed in parenthesis. If not, then you are not using multiple return values, you're only assigning the last element.]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.16 -->
  <rule>
    <key>org.codenarc.rule.groovyism.GetterMethodCouldBePropertyRule</key>
    <severity>MAJOR</severity>
    <name><![CDATA[Getter Method Could Be Property]]></name>
    <internalKey><![CDATA[GetterMethodCouldBeProperty]]></internalKey>
    <description><![CDATA[If a class defines a public method that follows the Java getter notation, and returns a constant, then it is cleaner to provide a Groovy property for the value rather than a Groovy method.]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.16 -->
  <rule>
    <key>org.codenarc.rule.groovyism.UseCollectManyRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Use Collect Many]]></name>
    <internalKey><![CDATA[UseCollectMany]]></internalKey>
    <description><![CDATA[In many case <em>collectMany()</em> yields the same result as <em>collect{}.flatten()</em>. It is easier to understand and more clearly conveys the intent.]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.16 -->
  <rule>
    <key>org.codenarc.rule.groovyism.CollectAllIsDeprecatedRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Collect All Is Deprecated]]></name>
    <internalKey><![CDATA[CollectAllIsDeprecated]]></internalKey>
    <description><![CDATA[collectAll{} is deprecated since Groovy 1.8.1. Use collectNested instead{}.]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.16 -->
  <rule>
    <key>org.codenarc.rule.groovyism.UseCollectNestedRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[Use Collect Nested]]></name>
    <internalKey><![CDATA[UseCollectNested]]></internalKey>
    <description><![CDATA[Instead of nested collect{}-calls use collectNested{}]]></description>
    <tag>groovyism</tag>
  </rule>

  <!-- since 0.19 -->
  <rule>
    <key>org.codenarc.rule.groovyism.GStringExpressionWithinStringRule</key>
    <severity>MINOR</severity>
    <name><![CDATA[G String Expression Within String]]></name>
    <internalKey><![CDATA[GStringExpressionWithinString]]></internalKey>
    <description><![CDATA[Check for regular (single quote) strings containing a GString-type expression (\${...}).]]></description>
    <tag>groovyism</tag>
  </rule>

</rules>
